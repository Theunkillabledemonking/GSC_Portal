// TimetableController.js -------------------------------------------------
// Ï†ÑÏ≤¥ Î°úÏßÅÏùÑ Í∞úÏÑ†Ìïú Î≤ÑÏ†Ñ. Node.js + Express + MySQL(pool) ÌôòÍ≤ΩÏóêÏÑú ÎèôÏûëÌïúÎã§.
//   1. Ï†ïÍ∑ú ÏàòÏóÖ Ï°∞ÌöåÏóêÏÑú level ÌïÑÌÑ∞Î•º Ï†úÍ±∞Ìï¥ "ÌïôÎÖÑ(year)" Í∏∞Ï§ÄÎßå Ï†ÅÏö©.
//   2. ÌäπÍ∞ï Ï°∞Ìöå Ïãú JSON_CONTAINS Î°ú group_levels Î∞∞Ïó¥ Îß§Ïπ≠.
//   3. ÏöîÏùº ÌôïÏû• Ïãú day_ko(ÌïúÍ∏Ä ÏöîÏùº)¬∑day_en(ÏòÅÎ¨∏ Îëê Í∏ÄÏûê)¬∑weekday_index(0‚Äë6) ÎèôÏãú Ï†úÍ≥µ.
//   4. getTimetableWithEvents Î°úÏßÅÏùÑ Î™®ÎìàÌôîÌï¥ Í∞ÄÎèÖÏÑ± Ìñ•ÏÉÅ.
//   5. Í∞Å Ìï®ÏàòÎßàÎã§ try/catch Î∞è ÏÉÅÏÑ∏ Î°úÍ∑∏Î°ú ÎîîÎ≤ÑÍπÖ Ìé∏ÏùòÏÑ± Í∞ïÌôî.
// -------------------------------------------------------------------------

const dayjs = require("dayjs");
const pool = require("../config/db");
const subjectController = require("./subjectController");
const { getPublicHolidaysInRangeWithFallback } = require("../services/holidayService");

// ------------------------ Ïú†Ìã∏Î¶¨Ìã∞ --------------------------------------

/**
 * ÏöîÏùº Î¨∏ÏûêÏó¥ÏùÑ 0‚Äë6 Ïà´ÏûêÎ°ú Îß§ÌïëÌïúÎã§.
 * ÌïúÍ∏Ä¬∑ÏòÅÎ¨∏(ÏÑ∏ Í∏ÄÏûê/Îëê Í∏ÄÏûê) Î™®Îëê ÏßÄÏõê.
 */
function mapDayOfWeek(day) {
    return {
        "Ïùº": 0, "Ïõî": 1, "Ìôî": 2, "Ïàò": 3, "Î™©": 4, "Í∏à": 5, "ÌÜ†": 6,
        "Sun": 0, "Mon": 1, "Tue": 2, "Wed": 3, "Thu": 4, "Fri": 5, "Sat": 6,
        "Su": 0,  "Mo": 1,  "Tu": 2,  "We": 3,  "Th": 4,  "Fr": 5,  "Sa": 6,
    }[day] ?? null;
}

/**
 * Ï£ºÏñ¥ÏßÑ Í∏∞Í∞Ñ(startDate~endDate) ÎèôÏïà ÌäπÏ†ï ÏöîÏùº ÏàòÏóÖÏùÑ Ïã§Ï†ú ÎÇ†Ïßú Î∞∞Ïó¥Î°ú ÌôïÏû•ÌïúÎã§.
 * Î∞òÌôò Í∞ùÏ≤¥Ïóê day_ko / day_en / weekday_index ÏÑ∏ ÌïÑÎìúÎ•º Ï∂îÍ∞ÄÌï¥
 * ÌîÑÎ°†Ìä∏ÏóêÏÑú Ïñ¥Îñ§ Ìè¨Îß∑Ïù¥Îì† Î∞îÎ°ú ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎèÑÎ°ù ÌñàÎã§.
 */
function expandTimetableToDates(timetable, startDate, endDate) {
    const result = [];
    const start = dayjs(startDate).startOf('day');
    const end   = dayjs(endDate).endOf('day');
    const weekday = mapDayOfWeek(timetable.day);

    // ÏãúÏûëÏùºÎ∂ÄÌÑ∞ Ï¢ÖÎ£åÏùºÍπåÏßÄ ÌïòÎ£®Ïî© ÏàúÌöå
    for (let d = start; d.isBefore(end) || d.isSame(end, 'day'); d = d.add(1, 'day')) {
        if (d.day() === weekday) {
            result.push({
                ...timetable,
                date: d.format("YYYY-MM-DD"),
                day_ko: timetable.day,      // Ïòà: "Ìôî"
                day_en: d.format("dd"),     // Ïòà: "Tu"
                weekday_index: weekday,     // 0‚Äë6
            });
        }
    }
    return result;
}

/**
 * period_time_map ÌÖåÏù¥Î∏îÏùÑ Ìïú Î≤à ÏùΩÏñ¥ Map(period -> { start_time, end_time })ÏúºÎ°ú Î≥ÄÌôò.
 */
async function getPeriodMap() {
    const [rows] = await pool.query("SELECT * FROM period_time_map");
    return Object.fromEntries(rows.map(p => [p.period, p]));
}

// ------------------------ Í≥ºÎ™© ------------------------
exports.getSubjects = async (req, res) => subjectController.getSubjects(req, res);
exports.getSubjectsByYear = async (req, res) => subjectController.getSubjectsByYear(req, res);

// ------------------------ Ï†ïÍ∑ú ÏãúÍ∞ÑÌëú -----------------
/**
 * /timetables?year=2&semester=spring
 * ÌïôÎÖÑ¬∑ÌïôÍ∏∞ Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÍ∑ú ÏàòÏóÖ Î™©Î°ùÏùÑ Î∞òÌôòÌïúÎã§.
 * ‚Äª level ÌååÎùºÎØ∏ÌÑ∞Îäî Î¨¥ÏãúÌïúÎã§(Ï†ïÍ∑ú ÏàòÏóÖÏùÄ ÌïôÎÖÑÎßåÏúºÎ°ú Í≤∞Ï†ï).
 */
exports.getTimetables = async (req, res) => {
    const { year, semester, day } = req.query;

    if (!semester) {
        return res.status(400).json({ message: "semester ÌååÎùºÎØ∏ÌÑ∞ ÌïÑÏàò" });
    }

    try {
        // Í∏∞Î≥∏ ÏøºÎ¶¨ Íµ¨ÏÑ±
        let query = `
            SELECT t.*, s.name AS subject_name
            FROM timetables t
            LEFT JOIN subjects s ON t.subject_id = s.id
            WHERE t.semester = ?
            AND t.is_special_lecture = 0
        `;
        const params = [semester];

        // ÌïôÎÖÑ ÌïÑÌÑ∞ Ï∂îÍ∞Ä (ÏòµÏÖò)
        if (year) {
            query += ` AND t.year = ?`;
            params.push(year);
        }

        // ÏöîÏùº ÌïÑÌÑ∞ Ï∂îÍ∞Ä (ÏòµÏÖò)
        if (day) {
            query += ` AND t.day = ?`;
            params.push(day);
        }

        const [rows] = await pool.query(query, params);
        const periodMap = await getPeriodMap();

        // ÌòÑÏû¨ ÎÇ†Ïßú Í∏∞Ï§ÄÏúºÎ°ú Ìú¥Í∞ï/Î≥¥Í∞ï Ï†ïÎ≥¥ Ï°∞Ìöå
        const today = dayjs().format('YYYY-MM-DD');
        const [events] = await pool.query(
            `SELECT * FROM timetable_events 
             WHERE event_date >= ? 
             AND (event_type = 'cancel' OR event_type = 'makeup')`,
            [today]
        );

        // ÏàòÏóÖ Ï†ïÎ≥¥Ïóê Ìú¥Í∞ï/Î≥¥Í∞ï Ï†ïÎ≥¥ Ï∂îÍ∞Ä
        const formatted = rows.map(t => {
            // Ìï¥Îãπ ÏàòÏóÖÏùò Ìú¥Í∞ï/Î≥¥Í∞ï Ïù¥Î≤§Ìä∏ Ï∞æÍ∏∞
            const relatedEvents = events.filter(e => 
                e.timetable_id === t.id || 
                (e.subject_id === t.subject_id && 
                 !(e.end_period < t.start_period || e.start_period > t.end_period))
            );

            return {
                ...t,
                subject_name: t.subject_name || "ÎØ∏ÏßÄÏ†ï Í≥ºÎ™©",
                professor_name: t.professor_name || "ÎØ∏ÏßÄÏ†ï ÍµêÏàò",
                start_time: periodMap[t.start_period]?.start_time,
                end_time: periodMap[t.end_period]?.end_time,
                events: relatedEvents.map(e => ({
                    id: e.id,
                    event_type: e.event_type,
                    event_date: e.event_date,
                    description: e.description
                }))
            };
        });

        res.json({ timetables: formatted });
    } catch (err) {
        console.error("‚ùå getTimetables Ïò§Î•ò:", err);
        res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù" });
    }
};

// ------------------------ ÌäπÍ∞ï -----------------------
/**
 * /special-lectures?semester=spring&level=mid&group_level=A&start_date=2025-03-01&end_date=2025-06-30
 * Î†àÎ≤®¬∑Í∑∏Î£π¬∑ÌïôÍ∏∞ Î≤îÏúÑÏóê ÎßûÎäî ÌäπÍ∞ïÏùÑ ÏöîÏùºÎ≥ÑÎ°ú ÎÇ†Ïßú ÌôïÏû•Ìï¥ Î∞òÌôòÌïúÎã§.
 */
// ‚úÖ [ÌäπÍ∞ï Ï°∞Ìöå API]
exports.getSpecialLectures = async (req, res) => {
    const { level, start_date, end_date, group_level = "A", semester } = req.query;

    if (!start_date || !end_date || !semester) {
        return res.status(400).json({ message: "semester, start_date, end_dateÎäî ÌïÑÏàòÏûÖÎãàÎã§." });
    }

    const ignoreLevelFilter = level === 'ALL' || !level;
    const ignoreGroupFilter = group_level === 'ALL' || !group_level;

    try {
        let query = `
            SELECT t.*, s.name AS subject_name
            FROM timetables t
                     LEFT JOIN subjects s ON t.subject_id = s.id
            WHERE t.semester = ?
              AND t.is_special_lecture = 1
        `;
        const params = [semester];

        if (!ignoreLevelFilter) {
            query += ` AND (t.level = ? OR t.level IS NULL)`;
            params.push(level);
        }

        if (!ignoreGroupFilter) {
            query += ` AND (t.group_levels IS NULL OR JSON_CONTAINS(t.group_levels, JSON_QUOTE(?)))`;
            params.push(group_level);
        }
        console.log("üîç ÏøºÎ¶¨:", query.trim());
        console.log("üßæ ÌååÎùºÎØ∏ÌÑ∞:", params);

        const [specials] = await pool.query(query, params);

        const periodMap = await getPeriodMap();
        const expanded = [];

        for (const t of specials) {
            const dates = expandTimetableToDates(t, start_date, end_date);
            for (const e of dates) {
                expanded.push({
                    ...e,
                    subject_name: t.subject_name || "ÎØ∏ÏßÄÏ†ï Í≥ºÎ™©",
                    professor_name: t.professor_name || "ÎØ∏ÏßÄÏ†ï ÍµêÏàò",
                    start_time: periodMap[e.start_period]?.start_time || "09:00",
                    end_time: periodMap[e.end_period]?.end_time || "18:00",
                    event_type: "special",
                });
            }
        }

        console.log(`üì¶ Î∞òÌôò ÌäπÍ∞ï Í∞úÏàò: ${expanded.length}`);
        res.json(expanded);

    } catch (err) {
        console.error("‚ùå getSpecialLectures Ïò§Î•ò:", err);
        res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù" });
    }
};

// ------------------------ ÌÜµÌï© Ï°∞Ìöå ------------------
/**
 * /timetable-with-events
 * Ï†ïÍ∑ú + ÌäπÍ∞ï + Ïù¥Î≤§Ìä∏ + Í≥µÌú¥ÏùºÏùÑ Ìïú Î≤àÏóê Î∞òÌôòÌïúÎã§.
 * ÌîÑÎ°†Ìä∏ÏóêÏÑú event_type Ïö∞ÏÑ†ÏàúÏúÑÎ°ú ÏÖÄ Í≤πÏπ® Ï≤òÎ¶¨.
 */
exports.getTimetableWithEvents = async (req, res) => {
    const {
        year,
        semester,
        start_date,
        end_date,
        level,
        group_level = "A",
        type = "all"
    } = req.query;

    if (!year || !semester || !start_date || !end_date) {
        return res.status(400).json({ message: "ÌïÑÏàò ÌååÎùºÎØ∏ÌÑ∞ ÎàÑÎùΩ" });
    }

    try {
        const holidays = await getPublicHolidaysInRangeWithFallback(start_date, end_date);
        const periodMap = await getPeriodMap();

        const [regulars] = await pool.query(`
            SELECT t.*, s.name AS subject_name
            FROM timetables t
            LEFT JOIN subjects s ON t.subject_id = s.id
            WHERE t.year = ? AND t.semester = ? AND t.is_special_lecture = 0
        `, [year, semester]);

        const [specials] = await pool.query(`
            SELECT t.*, s.name AS subject_name
            FROM timetables t
            LEFT JOIN subjects s ON t.subject_id = s.id
            WHERE t.semester = ?
              AND t.is_special_lecture = 1
              AND (t.level = ? OR t.level IS NULL)
              AND (t.group_levels IS NULL OR JSON_CONTAINS(t.group_levels, JSON_QUOTE(?)))
        `, [semester, level, group_level]);

        const [events] = await pool.query(`
            SELECT e.*, s.name AS subject_name,
                   DATE_FORMAT(e.event_date, '%Y-%m-%d') AS event_date_local,
                   t.day AS original_day,
                   t.year AS original_year, 
                   t.level AS original_level, 
                   t.start_period AS original_start_period,
                   t.end_period AS original_end_period,
                   t.professor_name AS original_professor,
                   t.subject_id AS original_subject_id,
                   t.room AS original_room
            FROM timetable_events e
            LEFT JOIN subjects s ON e.subject_id = s.id
            LEFT JOIN timetables t ON e.timetable_id = t.id
            WHERE DATE(e.event_date) BETWEEN ? AND ?
              AND (
                  (e.event_type IN ('cancel', 'makeup') AND (
                      (t.is_special_lecture = 0 AND t.year = ?) OR
                      (t.is_special_lecture = 1 AND (t.level = ? OR t.level IS NULL))
                  )) OR
                  (e.event_type IN ('short_lecture', 'event') AND (
                      (e.year = ? OR e.year IS NULL) AND (e.level = ? OR e.level IS NULL)
                  ))
              )
              AND (
                  e.event_type IN ('cancel', 'makeup') OR
                  e.group_levels IS NULL OR e.group_levels = '[]' OR 
                  JSON_CONTAINS(e.group_levels, JSON_QUOTE(?))
              )
        `, [start_date, end_date, year, level, year, level, group_level]);

        const cancelMap = new Map();
        for (const ev of events) {
            if (ev.event_type === 'cancel') {
                const date = ev.event_date_local;
                if (!cancelMap.has(date)) cancelMap.set(date, new Set());
                cancelMap.get(date).add(ev.timetable_id);
            }
        }

        const baseLectures = (type === "regular")
            ? regulars : (type === "special")
                ? specials : [...regulars, ...specials];

        const result = [];
        const pushedEventSet = new Set();

        for (const lecture of baseLectures) {
            const dates = expandTimetableToDates(lecture, start_date, end_date);
            for (const instance of dates) {
                const isCancelled = cancelMap.get(instance.date)?.has(lecture.id);

                if (isCancelled) {
                    const cancelEvent = events.find(e =>
                        e.event_type === 'cancel' &&
                        e.event_date_local === instance.date &&
                        e.timetable_id === lecture.id
                    );

                    const dateValue = cancelEvent.event_date_local || cancelEvent.event_date || instance.date || null;

                    if (cancelEvent && !pushedEventSet.has(cancelEvent.id)) {
                        pushedEventSet.add(cancelEvent.id);
                        result.push({
                            ...instance,
                            id: `event-${cancelEvent.id}`,
                            event_type: "cancel",
                            date: dateValue,
                            description: cancelEvent.description || "Ìú¥Í∞ï",
                            isCancelled: true,
                            priority: 1,
                            original_class: {
                                day: cancelEvent.original_day,
                                start_period: cancelEvent.original_start_period,
                                end_period: cancelEvent.original_end_period,
                                year: cancelEvent.original_year,
                                level: cancelEvent.original_level,
                                room: cancelEvent.original_room,
                                professor_name: cancelEvent.original_professor,
                                subject_id: cancelEvent.original_subject_id
                            }
                        });
                    }
                } else {
                    result.push({
                        ...instance,
                        id: lecture.id,
                        event_type: lecture.is_special_lecture ? "special" : "regular",
                        subject_name: lecture.subject_name || "ÎØ∏ÏßÄÏ†ï",
                        professor_name: lecture.professor_name || "",
                        room: lecture.room || "",
                        start_time: periodMap[lecture.start_period]?.start_time || "09:00",
                        end_time: periodMap[lecture.end_period]?.end_time || "18:00",
                        isCancelled: false,
                        priority: lecture.is_special_lecture ? 3 : 5
                    });
                }
            }
        }

        for (const ev of events) {
            const key = `event-${ev.id}`;
            if (pushedEventSet.has(ev.id)) continue;

            result.push({
                id: key,
                event_type: ev.event_type,
                date: ev.event_date_local,
                subject_name: ev.subject_name || "ÎØ∏ÏßÄÏ†ï",
                professor_name: ev.professor_name || "",
                room: ev.room || "",
                description: ev.description || "",
                start_period: ev.start_period || 1,
                end_period: ev.end_period || 1,
                start_time: periodMap[ev.start_period]?.start_time || "09:00",
                end_time: periodMap[ev.end_period]?.end_time || "18:00",
                year: ev.original_year || ev.year || year,
                level: ev.original_level || ev.level || level,
                isCancelled: ev.event_type === "cancel",
                priority: {
                    cancel: 1,
                    makeup: 2,
                    short_lecture: 2,
                    event: 4
                }[ev.event_type] || 99,
                original_class: ev.event_type === 'cancel' || ev.event_type === 'makeup' ? {
                    day: ev.original_day,
                    start_period: ev.original_start_period,
                    end_period: ev.original_end_period,
                    year: ev.original_year,
                    level: ev.original_level,
                    room: ev.original_room,
                    professor_name: ev.original_professor,
                    subject_id: ev.original_subject_id
                } : null
            });
        }

        for (const holiday of holidays) {
            result.push({
                id: `holiday-${holiday}`,
                date: holiday,
                event_type: "holiday",
                subject_name: "Í≥µÌú¥Ïùº",
                description: "Í≥µÌú¥Ïùº",
                start_period: 1,
                end_period: 9,
                start_time: "09:00",
                end_time: "18:00",
                day_ko: dayjs(holiday).format("dd"),
                priority: 0
            });
        }

        res.json({ timetables: result, events, holidays });
    } catch (err) {
        console.error("‚ùå getTimetableWithEvents Ïò§Î•ò:", err);
        res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù" });
    }
};


// ------------------------ CRUD -----------------------
exports.createTimetable = async (req, res) => {
    const {
        year, level, subject_id, room = "", description = "",
        day, start_period, end_period,
        professor_name = "", semester,
        is_special_lecture = 0,
        group_levels = []  // üëà Ïó¨Í∏∞Î•º Í∏∞Î≥∏ Îπà Î∞∞Ïó¥Î°ú Î∞õÍ∏∞
    } = req.body;

    if (!year || !semester || !day || !start_period || !end_period || !subject_id) {
        return res.status(400).json({ message: "ÌïÑÏàò ÌïÑÎìúÍ∞Ä ÎàÑÎùΩÎêòÏóàÏäµÎãàÎã§." });
    }

    try {
        const [result] = await pool.query(
            `INSERT INTO timetables (
                year, level, subject_id, room, description,
                day, start_period, end_period, professor_name, semester, is_special_lecture, group_levels
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [
                year, level || null, subject_id, room, description,
                day, start_period, end_period, professor_name, semester,
                is_special_lecture,
                group_levels.length ? JSON.stringify(group_levels) : null // ‚úÖ ÌïµÏã¨
            ]
        );

        res.status(201).json({ status: "success", message: "ÏãúÍ∞ÑÌëú Îì±Î°ù ÏôÑÎ£å", data: { id: result.insertId } });
    } catch (err) {
        console.error("‚ùå createTimetable Ïò§Î•ò:", err);
        res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù" });
    }
};

exports.updateTimetable = async (req, res) => {
    const { id } = req.params;
    const {
        year, level, subject_id, room = "", description = "",
        day, start_period, end_period,
        professor_name = "", semester,
        is_special_lecture = 0,
    } = req.body;

    if (!id || !year || !semester || !day || !start_period || !end_period || !subject_id) {
        return res.status(400).json({ message: "ÌïÑÏàò ÌïÑÎìú ÎàÑÎùΩ" });
    }

    try {
        const [result] = await pool.query(
            `UPDATE timetables SET
                                   year = ?, level = ?, subject_id = ?, room = ?, description = ?,
                                   day = ?, start_period = ?, end_period = ?, professor_name = ?,
                                   semester = ?, is_special_lecture = ?
             WHERE id = ?`,
            [year, level || null, subject_id, room, description,
                day, start_period, end_period, professor_name,
                semester, is_special_lecture, id]
        );

        if (result.affectedRows === 0) {
            return res.status(404).json({ message: "Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÏãúÍ∞ÑÌëú" });
        }

        res.json({ status: "success", message: "ÏàòÏ†ï ÏôÑÎ£å", data: { id } });
    } catch (err) {
        console.error("‚ùå updateTimetable Ïò§Î•ò:", err);
        res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù" });
    }
};

exports.deleteTimetable = async (req, res) => {
    const { id } = req.params;

    if (!id) return res.status(400).json({ message: "ID ÌïÑÏöî" });

    try {
        const [result] = await pool.query("DELETE FROM timetables WHERE id = ?", [id]);
        if (result.affectedRows === 0) {
            return res.status(404).json({ message: "ÏÇ≠Ï†úÌï† ÏàòÏóÖÏù¥ ÏóÜÏùå" });
        }

        res.json({ status: "success", message: "ÏÇ≠Ï†ú ÏôÑÎ£å", data: { id } });
    } catch (err) {
        console.error("‚ùå deleteTimetable Ïò§Î•ò:", err);
        res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù" });
    }
};
