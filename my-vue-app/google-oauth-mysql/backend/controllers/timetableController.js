// TimetableController.js -------------------------------------------------
// Ï†ÑÏ≤¥ Î°úÏßÅÏùÑ Í∞úÏÑ†Ìïú Î≤ÑÏ†Ñ. Node.js + Express + MySQL(pool) ÌôòÍ≤ΩÏóêÏÑú ÎèôÏûëÌïúÎã§.
//   1. Ï†ïÍ∑ú ÏàòÏóÖ Ï°∞ÌöåÏóêÏÑú level ÌïÑÌÑ∞Î•º Ï†úÍ±∞Ìï¥ "ÌïôÎÖÑ(year)" Í∏∞Ï§ÄÎßå Ï†ÅÏö©.
//   2. ÌäπÍ∞ï Ï°∞Ìöå Ïãú JSON_CONTAINS Î°ú group_levels Î∞∞Ïó¥ Îß§Ïπ≠.
//   3. ÏöîÏùº ÌôïÏû• Ïãú day_ko(ÌïúÍ∏Ä ÏöîÏùº)¬∑day_en(ÏòÅÎ¨∏ Îëê Í∏ÄÏûê)¬∑weekday_index(0‚Äë6) ÎèôÏãú Ï†úÍ≥µ.
//   4. getTimetableWithEvents Î°úÏßÅÏùÑ Î™®ÎìàÌôîÌï¥ Í∞ÄÎèÖÏÑ± Ìñ•ÏÉÅ.
//   5. Í∞Å Ìï®ÏàòÎßàÎã§ try/catch Î∞è ÏÉÅÏÑ∏ Î°úÍ∑∏Î°ú ÎîîÎ≤ÑÍπÖ Ìé∏ÏùòÏÑ± Í∞ïÌôî.
// -------------------------------------------------------------------------

const dayjs = require("dayjs");
const pool = require("../config/db");
const subjectController = require("./subjectController");
const { getPublicHolidaysInRangeWithFallback } = require("../services/holidayService");

// ------------------------ Ïú†Ìã∏Î¶¨Ìã∞ --------------------------------------

/**
 * ÏöîÏùº Î¨∏ÏûêÏó¥ÏùÑ 0‚Äë6 Ïà´ÏûêÎ°ú Îß§ÌïëÌïúÎã§.
 * ÌïúÍ∏Ä¬∑ÏòÅÎ¨∏(ÏÑ∏ Í∏ÄÏûê/Îëê Í∏ÄÏûê) Î™®Îëê ÏßÄÏõê.
 */
function mapDayOfWeek(day) {
    return {
        "Ïùº": 0, "Ïõî": 1, "Ìôî": 2, "Ïàò": 3, "Î™©": 4, "Í∏à": 5, "ÌÜ†": 6,
        "Sun": 0, "Mon": 1, "Tue": 2, "Wed": 3, "Thu": 4, "Fri": 5, "Sat": 6,
        "Su": 0,  "Mo": 1,  "Tu": 2,  "We": 3,  "Th": 4,  "Fr": 5,  "Sa": 6,
    }[day] ?? null;
}

/**
 * Ï£ºÏñ¥ÏßÑ Í∏∞Í∞Ñ(startDate~endDate) ÎèôÏïà ÌäπÏ†ï ÏöîÏùº ÏàòÏóÖÏùÑ Ïã§Ï†ú ÎÇ†Ïßú Î∞∞Ïó¥Î°ú ÌôïÏû•ÌïúÎã§.
 * Î∞òÌôò Í∞ùÏ≤¥Ïóê day_ko / day_en / weekday_index ÏÑ∏ ÌïÑÎìúÎ•º Ï∂îÍ∞ÄÌï¥
 * ÌîÑÎ°†Ìä∏ÏóêÏÑú Ïñ¥Îñ§ Ìè¨Îß∑Ïù¥Îì† Î∞îÎ°ú ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎèÑÎ°ù ÌñàÎã§.
 */
function expandTimetableToDates(timetable, startDate, endDate) {
    const result = [];
    const start = dayjs(startDate).startOf('day');
    const end   = dayjs(endDate).endOf('day');
    const weekday = mapDayOfWeek(timetable.day);

    // ÏãúÏûëÏùºÎ∂ÄÌÑ∞ Ï¢ÖÎ£åÏùºÍπåÏßÄ ÌïòÎ£®Ïî© ÏàúÌöå
    for (let d = start; d.isBefore(end) || d.isSame(end, 'day'); d = d.add(1, 'day')) {
        if (d.day() === weekday) {
            result.push({
                ...timetable,
                date: d.format("YYYY-MM-DD"),
                day_ko: timetable.day,      // Ïòà: "Ìôî"
                day_en: d.format("dd"),     // Ïòà: "Tu"
                weekday_index: weekday,     // 0‚Äë6
            });
        }
    }
    return result;
}

/**
 * period_time_map ÌÖåÏù¥Î∏îÏùÑ Ìïú Î≤à ÏùΩÏñ¥ Map(period -> { start_time, end_time })ÏúºÎ°ú Î≥ÄÌôò.
 */
async function getPeriodMap() {
    const [rows] = await pool.query("SELECT * FROM period_time_map");
    return Object.fromEntries(rows.map(p => [p.period, p]));
}

// ------------------------ Í≥ºÎ™© ------------------------
exports.getSubjects = async (req, res) => subjectController.getSubjects(req, res);
exports.getSubjectsByYear = async (req, res) => subjectController.getSubjectsByYear(req, res);

// ------------------------ Ï†ïÍ∑ú ÏãúÍ∞ÑÌëú -----------------
/**
 * /timetables?year=2&semester=spring
 * ÌïôÎÖÑ¬∑ÌïôÍ∏∞ Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÍ∑ú ÏàòÏóÖ Î™©Î°ùÏùÑ Î∞òÌôòÌïúÎã§.
 * ‚Äª level ÌååÎùºÎØ∏ÌÑ∞Îäî Î¨¥ÏãúÌïúÎã§(Ï†ïÍ∑ú ÏàòÏóÖÏùÄ ÌïôÎÖÑÎßåÏúºÎ°ú Í≤∞Ï†ï).
 */
exports.getTimetables = async (req, res) => {
    const { year, semester, day } = req.query;

    if (!semester) {
        return res.status(400).json({ message: "semester ÌååÎùºÎØ∏ÌÑ∞ ÌïÑÏàò" });
    }

    try {
        // Í∏∞Î≥∏ ÏøºÎ¶¨ Íµ¨ÏÑ±
        let query = `
            SELECT t.*, s.name AS subject_name
            FROM timetables t
            LEFT JOIN subjects s ON t.subject_id = s.id
            WHERE t.semester = ?
            AND t.is_special_lecture = 0
        `;
        const params = [semester];

        // ÌïôÎÖÑ ÌïÑÌÑ∞ Ï∂îÍ∞Ä (ÏòµÏÖò)
        if (year) {
            query += ` AND t.year = ?`;
            params.push(year);
        }

        // ÏöîÏùº ÌïÑÌÑ∞ Ï∂îÍ∞Ä (ÏòµÏÖò)
        if (day) {
            query += ` AND t.day = ?`;
            params.push(day);
        }

        const [rows] = await pool.query(query, params);
        const periodMap = await getPeriodMap();

        // ÌòÑÏû¨ ÎÇ†Ïßú Í∏∞Ï§ÄÏúºÎ°ú Ìú¥Í∞ï/Î≥¥Í∞ï Ï†ïÎ≥¥ Ï°∞Ìöå
        const today = dayjs().format('YYYY-MM-DD');
        const [events] = await pool.query(
            `SELECT * FROM timetable_events 
             WHERE event_date >= ? 
             AND (event_type = 'cancel' OR event_type = 'makeup')`,
            [today]
        );

        // ÏàòÏóÖ Ï†ïÎ≥¥Ïóê Ìú¥Í∞ï/Î≥¥Í∞ï Ï†ïÎ≥¥ Ï∂îÍ∞Ä
        const formatted = rows.map(t => {
            // Ìï¥Îãπ ÏàòÏóÖÏùò Ìú¥Í∞ï/Î≥¥Í∞ï Ïù¥Î≤§Ìä∏ Ï∞æÍ∏∞
            const relatedEvents = events.filter(e => 
                e.timetable_id === t.id || 
                (e.subject_id === t.subject_id && 
                 !(e.end_period < t.start_period || e.start_period > t.end_period))
            );

            return {
                ...t,
                subject_name: t.subject_name || "ÎØ∏ÏßÄÏ†ï Í≥ºÎ™©",
                professor_name: t.professor_name || "ÎØ∏ÏßÄÏ†ï ÍµêÏàò",
                start_time: periodMap[t.start_period]?.start_time,
                end_time: periodMap[t.end_period]?.end_time,
                events: relatedEvents.map(e => ({
                    id: e.id,
                    event_type: e.event_type,
                    event_date: e.event_date,
                    description: e.description
                }))
            };
        });

        res.json({ timetables: formatted });
    } catch (err) {
        console.error("‚ùå getTimetables Ïò§Î•ò:", err);
        res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù" });
    }
};

// ------------------------ ÌäπÍ∞ï -----------------------
/**
 * /special-lectures?semester=spring&level=mid&group_level=A&start_date=2025-03-01&end_date=2025-06-30
 * Î†àÎ≤®¬∑Í∑∏Î£π¬∑ÌïôÍ∏∞ Î≤îÏúÑÏóê ÎßûÎäî ÌäπÍ∞ïÏùÑ ÏöîÏùºÎ≥ÑÎ°ú ÎÇ†Ïßú ÌôïÏû•Ìï¥ Î∞òÌôòÌïúÎã§.
 */
// ‚úÖ [ÌäπÍ∞ï Ï°∞Ìöå API]
exports.getSpecialLectures = async (req, res) => {
    const { level, start_date, end_date, group_level = "A", semester } = req.query;

    if (!start_date || !end_date || !semester) {
        return res.status(400).json({ message: "semester, start_date, end_dateÎäî ÌïÑÏàòÏûÖÎãàÎã§." });
    }

    const ignoreLevelFilter = level === 'ALL' || !level;
    const ignoreGroupFilter = group_level === 'ALL' || !group_level;

    try {
        let query = `
            SELECT t.*, s.name AS subject_name
            FROM timetables t
                     LEFT JOIN subjects s ON t.subject_id = s.id
            WHERE t.semester = ?
              AND t.is_special_lecture = 1
        `;
        const params = [semester];

        if (!ignoreLevelFilter) {
            query += ` AND (t.level = ? OR t.level IS NULL)`;
            params.push(level);
        }

        if (!ignoreGroupFilter) {
            query += ` AND (t.group_levels IS NULL OR JSON_CONTAINS(t.group_levels, JSON_QUOTE(?)))`;
            params.push(group_level);
        }
        console.log("üîç ÏøºÎ¶¨:", query.trim());
        console.log("üßæ ÌååÎùºÎØ∏ÌÑ∞:", params);

        const [specials] = await pool.query(query, params);

        const periodMap = await getPeriodMap();
        const expanded = [];

        for (const t of specials) {
            const dates = expandTimetableToDates(t, start_date, end_date);
            for (const e of dates) {
                expanded.push({
                    ...e,
                    subject_name: t.subject_name || "ÎØ∏ÏßÄÏ†ï Í≥ºÎ™©",
                    professor_name: t.professor_name || "ÎØ∏ÏßÄÏ†ï ÍµêÏàò",
                    start_time: periodMap[e.start_period]?.start_time || "09:00",
                    end_time: periodMap[e.end_period]?.end_time || "18:00",
                    event_type: "special",
                });
            }
        }

        console.log(`üì¶ Î∞òÌôò ÌäπÍ∞ï Í∞úÏàò: ${expanded.length}`);
        res.json(expanded);

    } catch (err) {
        console.error("‚ùå getSpecialLectures Ïò§Î•ò:", err);
        res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù" });
    }
};

// ------------------------ ÌÜµÌï© Ï°∞Ìöå ------------------
/**
 * /timetable-with-events
 * Ï†ïÍ∑ú + ÌäπÍ∞ï + Ïù¥Î≤§Ìä∏ + Í≥µÌú¥ÏùºÏùÑ Ìïú Î≤àÏóê Î∞òÌôòÌïúÎã§.
 * ÌîÑÎ°†Ìä∏ÏóêÏÑú event_type Ïö∞ÏÑ†ÏàúÏúÑÎ°ú ÏÖÄ Í≤πÏπ® Ï≤òÎ¶¨.
 */
exports.getTimetableWithEvents = async (req, res) => {
    const {
        year,
        semester,
        start_date,
        end_date,
        level,
        group_level = "A",
        type = "all"
    } = req.query;

    if (!year || !semester || !start_date || !end_date) {
        return res.status(400).json({ message: "ÌïÑÏàò ÌååÎùºÎØ∏ÌÑ∞ ÎàÑÎùΩ" });
    }

    try {
        const holidays = await getPublicHolidaysInRangeWithFallback(start_date, end_date);
        const periodMap = await getPeriodMap();

        const [regulars] = await pool.query(`
            SELECT t.*, s.name AS subject_name
            FROM timetables t
            LEFT JOIN subjects s ON t.subject_id = s.id
            WHERE t.year = ? AND t.semester = ? AND t.is_special_lecture = 0
        `, [year, semester]);

        const [specials] = await pool.query(`
            SELECT t.*, s.name AS subject_name
            FROM timetables t
            LEFT JOIN subjects s ON t.subject_id = s.id
            WHERE t.semester = ?
              AND t.is_special_lecture = 1
              AND (t.level = ? OR t.level IS NULL)
              AND (t.group_levels IS NULL OR JSON_CONTAINS(t.group_levels, JSON_QUOTE(?)))
        `, [semester, level, group_level]);

        const [events] = await pool.query(`
            SELECT e.*, s.name AS subject_name,
                   DATE_FORMAT(e.event_date, '%Y-%m-%d') AS event_date_local,
                   t.day AS original_day,
                   t.year AS original_year, 
                   t.level AS original_level, 
                   t.start_period AS original_start_period,
                   t.end_period AS original_end_period,
                   t.professor_name AS original_professor,
                   t.subject_id AS original_subject_id,
                   t.room AS original_room
            FROM timetable_events e
            LEFT JOIN subjects s ON e.subject_id = s.id
            LEFT JOIN timetables t ON e.timetable_id = t.id
            WHERE DATE(e.event_date) BETWEEN ? AND ?
              AND (
                  (e.event_type IN ('cancel', 'makeup') AND (
                      (t.is_special_lecture = 0 AND t.year = ?) OR
                      (t.is_special_lecture = 1 AND (t.level = ? OR t.level IS NULL))
                  )) OR
                  (e.event_type IN ('short_lecture', 'event') AND (
                      (e.year = ? OR e.year IS NULL) AND (e.level = ? OR e.level IS NULL)
                  ))
              )
              AND (
                  e.event_type IN ('cancel', 'makeup') OR
                  e.group_levels IS NULL OR e.group_levels = '[]' OR 
                  JSON_CONTAINS(e.group_levels, JSON_QUOTE(?))
              )
        `, [start_date, end_date, year, level, year, level, group_level]);

        const cancelMap = new Map();
        for (const ev of events) {
            if (ev.event_type === 'cancel') {
                const date = ev.event_date_local;
                if (!cancelMap.has(date)) cancelMap.set(date, new Set());
                cancelMap.get(date).add(ev.timetable_id);
            }
        }

        const baseLectures = (type === "regular")
            ? regulars : (type === "special")
                ? specials : [...regulars, ...specials];

        const result = [];
        const pushedEventSet = new Set();

        for (const lecture of baseLectures) {
            const dates = expandTimetableToDates(lecture, start_date, end_date);
            for (const instance of dates) {
                const isCancelled = cancelMap.get(instance.date)?.has(lecture.id);

                if (isCancelled) {
                    const cancelEvent = events.find(e =>
                        e.event_type === 'cancel' &&
                        e.event_date_local === instance.date &&
                        e.timetable_id === lecture.id
                    );

                    const dateValue = cancelEvent.event_date_local || cancelEvent.event_date || instance.date || null;

                    if (cancelEvent && !pushedEventSet.has(cancelEvent.id)) {
                        pushedEventSet.add(cancelEvent.id);
                        result.push({
                            ...instance,
                            id: `event-${cancelEvent.id}`,
                            event_type: "cancel",
                            date: dateValue,
                            description: cancelEvent.description || "Ìú¥Í∞ï",
                            isCancelled: true,
                            priority: 1,
                            original_class: {
                                day: cancelEvent.original_day,
                                start_period: cancelEvent.original_start_period,
                                end_period: cancelEvent.original_end_period,
                                year: cancelEvent.original_year,
                                level: cancelEvent.original_level,
                                room: cancelEvent.original_room,
                                professor_name: cancelEvent.original_professor,
                                subject_id: cancelEvent.original_subject_id
                            }
                        });
                    }
                } else {
                    result.push({
                        ...instance,
                        id: lecture.id,
                        event_type: lecture.is_special_lecture ? "special" : "regular",
                        subject_name: lecture.subject_name || "ÎØ∏ÏßÄÏ†ï",
                        professor_name: lecture.professor_name || "",
                        room: lecture.room || "",
                        start_time: periodMap[lecture.start_period]?.start_time || "09:00",
                        end_time: periodMap[lecture.end_period]?.end_time || "18:00",
                        isCancelled: false,
                        priority: lecture.is_special_lecture ? 3 : 5
                    });
                }
            }
        }

        for (const ev of events) {
            const key = `event-${ev.id}`;
            if (pushedEventSet.has(ev.id)) continue;

            result.push({
                id: key,
                event_type: ev.event_type,
                date: ev.event_date_local,
                subject_name: ev.subject_name || "ÎØ∏ÏßÄÏ†ï",
                professor_name: ev.professor_name || "",
                room: ev.room || "",
                description: ev.description || "",
                start_period: ev.start_period || 1,
                end_period: ev.end_period || 1,
                start_time: periodMap[ev.start_period]?.start_time || "09:00",
                end_time: periodMap[ev.end_period]?.end_time || "18:00",
                year: ev.original_year || ev.year || year,
                level: ev.original_level || ev.level || level,
                isCancelled: ev.event_type === "cancel",
                priority: {
                    cancel: 1,
                    makeup: 2,
                    short_lecture: 2,
                    event: 4
                }[ev.event_type] || 99,
                original_class: ev.event_type === 'cancel' || ev.event_type === 'makeup' ? {
                    day: ev.original_day,
                    start_period: ev.original_start_period,
                    end_period: ev.original_end_period,
                    year: ev.original_year,
                    level: ev.original_level,
                    room: ev.original_room,
                    professor_name: ev.original_professor,
                    subject_id: ev.original_subject_id
                } : null
            });
        }

        for (const holiday of holidays) {
            result.push({
                id: `holiday-${holiday}`,
                date: holiday,
                event_type: "holiday",
                subject_name: "Í≥µÌú¥Ïùº",
                description: "Í≥µÌú¥Ïùº",
                start_period: 1,
                end_period: 9,
                start_time: "09:00",
                end_time: "18:00",
                day_ko: dayjs(holiday).format("dd"),
                priority: 0
            });
        }

        res.json({ timetables: result, events, holidays });
    } catch (err) {
        console.error("‚ùå getTimetableWithEvents Ïò§Î•ò:", err);
        res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù" });
    }
};

// ------------------------ Ï£ºÍ∞Ñ ÏãúÍ∞ÑÌëú Ïù¥Î≤§Ìä∏ -----------------
/**
 * GET /api/timetable/events
 * ÌïôÎÖÑ/Î†àÎ≤® Í∏∞Ï§ÄÏúºÎ°ú ÏãúÍ∞ÑÌëú Ïù¥Î≤§Ìä∏Î•º Ï°∞ÌöåÌïúÎã§.
 * - Ï†ïÍ∑ú ÏàòÏóÖ: ÌïôÎÖÑ(year) Í∏∞Ï§Ä
 * - ÌäπÍ∞ï: Î†àÎ≤®(level) + Í∑∏Î£π(group_levels) + Ïô∏Íµ≠Ïù∏ ÎåÄÏÉÅ(is_foreigner_target) Í∏∞Ï§Ä
 * - Í≥µÌú¥Ïùº: ÎÇ†Ïßú(date) Í∏∞Ï§Ä
 */
exports.getEvents = async (req, res) => {
    const { grade, level, week, is_foreigner } = req.query;
    
    if (!grade) {
        return res.status(400).json({ message: "gradeÎäî ÌïÑÏàò ÌååÎùºÎØ∏ÌÑ∞ÏûÖÎãàÎã§." });
    }

    try {
        const weekStart = dayjs(week || new Date()).startOf('week');
        const weekEnd = dayjs(week || new Date()).endOf('week');
        console.log(`Ï£º Î≤îÏúÑ: ${weekStart.format('YYYY-MM-DD')} ~ ${weekEnd.format('YYYY-MM-DD')}`);
        
        // Ïô∏Íµ≠Ïù∏ Ï°∞Í±¥ Ï≤òÎ¶¨ (Î¨∏ÏûêÏó¥ÏùÑ Î∂àÎ¶¨Ïñ∏ÏúºÎ°ú Î≥ÄÌôò)
        const isForeigner = is_foreigner === 'true' || is_foreigner === '1';
        
        // 1. Ï†ïÍ∑ú ÏàòÏóÖ Ï°∞Ìöå (ÌïôÎÖÑ Í∏∞Ï§Ä)
        const [regulars] = await pool.query(`
            SELECT 
                t.*,
                s.name AS subject_name,
                'regular' AS event_type
            FROM timetables t
            LEFT JOIN subjects s ON t.subject_id = s.id
            WHERE t.year = ?
            AND t.is_special_lecture = 0
        `, [grade]);
        console.log(`Ï†ïÍ∑ú ÏàòÏóÖ Ï°∞Ìöå: ${regulars.length}Í∞ú`);

        // 2. ÌäπÍ∞ï Ï°∞Ìöå (Î†àÎ≤® + Í∑∏Î£π Í∏∞Ï§Ä)
        const [specials] = await pool.query(`
            SELECT 
                t.*,
                s.name AS subject_name,
                'special' AS event_type
            FROM timetables t
            LEFT JOIN subjects s ON t.subject_id = s.id
            WHERE t.is_special_lecture = 1
            AND (t.level = ? OR t.level IS NULL)
            AND (
                t.group_levels IS NULL 
                OR JSON_CONTAINS(t.group_levels, JSON_QUOTE(?))
            )
        `, [level || 'N1', 'A']);
        console.log(`ÌäπÍ∞ï Ï°∞Ìöå: ${specials.length}Í∞ú`);

        // 3. Ìú¥Í∞ï/Î≥¥Í∞ï Ïù¥Î≤§Ìä∏ Ï°∞Ìöå
        let eventsQuery = `
            SELECT e.*, s.name AS subject_name, e.event_type AS type, t.year as timetable_year
            FROM timetable_events e
            LEFT JOIN subjects s ON e.subject_id = s.id
            LEFT JOIN timetables t ON e.timetable_id = t.id
            WHERE e.event_date BETWEEN ? AND ?
        `;

        const eventsParams = [weekStart, weekEnd];

        // ÌïôÎÖÑ ÌïÑÌÑ∞ Ï†ÅÏö© (Ïù¥Î≤§Ìä∏)
        const ignoreGradeFilter = !grade;
        if (!ignoreGradeFilter) {
            eventsQuery += ` AND (t.year = ? OR e.year = ? OR (t.year IS NULL AND e.year IS NULL))`;
            eventsParams.push(grade, grade);
        }

        console.log(`üîç Ïù¥Î≤§Ìä∏ ÏøºÎ¶¨: ${eventsQuery}`);
        console.log(`üîç Ïù¥Î≤§Ìä∏ ÌååÎùºÎØ∏ÌÑ∞: ${eventsParams}`);

        const [events] = await pool.query(eventsQuery, eventsParams);
        console.log(`üìä Ïù¥Î≤§Ìä∏ Ï°∞Ìöå Í≤∞Í≥º: ${events.length}Í∞ú`);

        // 4. Í≥µÌú¥Ïùº Ï°∞Ìöå
        const holidays = await getPublicHolidaysInRangeWithFallback(
            weekStart.format('YYYY-MM-DD'),
            weekEnd.format('YYYY-MM-DD')
        );
        console.log(`Í≥µÌú¥Ïùº Ï°∞Ìöå: ${holidays.length}Í∞ú`);

        // 5. Î™®Îì† Ïù¥Î≤§Ìä∏Î•º ÏöîÏùºÎ≥Ñ, ÍµêÏãúÎ≥ÑÎ°ú Ï†ïÎ¶¨
        const allEvents = [];
        
        // Ï†ïÍ∑ú ÏàòÏóÖ Ï≤òÎ¶¨
        regulars.forEach(t => {
            allEvents.push({
                id: t.id,
                event_type: t.event_type,
                day: t.day,
                start_period: t.start_period,
                end_period: t.end_period,
                subject_name: t.subject_name || "ÎØ∏ÏßÄÏ†ï Í≥ºÎ™©",
                professor_name: t.professor_name || "ÎØ∏ÏßÄÏ†ï ÍµêÏàò",
                room: t.room || "",
                year: parseInt(t.year),
                level: t.level,
                is_foreigner_target: false
            });
        });
        
        // ÌäπÍ∞ï Ï≤òÎ¶¨
        specials.forEach(t => {
            allEvents.push({
                id: t.id,
                event_type: t.event_type,
                day: t.day,
                start_period: t.start_period,
                end_period: t.end_period,
                subject_name: t.subject_name || "ÎØ∏ÏßÄÏ†ï Í≥ºÎ™©",
                professor_name: t.professor_name || "ÎØ∏ÏßÄÏ†ï ÍµêÏàò",
                room: t.room || "",
                year: parseInt(t.year),
                level: t.level,
                is_foreigner_target: false
            });
        });
        
        // Ïù¥Î≤§Ìä∏(Ìú¥Í∞ï/Î≥¥Í∞ï) Ï≤òÎ¶¨
        events.forEach(e => {
            // Ïù¥Î≤§Ìä∏ ÎÇ†ÏßúÎ°úÎ∂ÄÌÑ∞ ÏöîÏùº Ï∂îÏ∂ú (0: Ïùº, 1: Ïõî, ... 6: ÌÜ†)
            const eventDate = dayjs(e.event_date);
            const dayOfWeek = eventDate.day();
            
            // Ïà´Ïûê ÏöîÏùº Ïù∏Îç±Ïä§Î•º ÏöîÏùº Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
            const dayMap = {1: 'Ïõî', 2: 'Ìôî', 3: 'Ïàò', 4: 'Î™©', 5: 'Í∏à'};
            const day = dayMap[dayOfWeek] || null;
            
            if (day) { // ÌèâÏùºÏù∏ Í≤ΩÏö∞Îßå Ï∂îÍ∞Ä
                // ÏõêÎ≥∏ ÏàòÏóÖÏóêÏÑú ÍµêÏàò, Í∞ïÏùòÏã§ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
                const originalTimetable = e.timetable_id ? timetables.find(t => t.id === e.timetable_id) : null;
                
                allEvents.push({
                    id: e.id,
                    event_type: e.event_type,
                    event_date: e.event_date,
                    day: day, // ÏöîÏùº Ï∂îÍ∞Ä
                    start_period: e.start_period,
                    end_period: e.end_period,
                    subject_name: e.subject_name || "ÎØ∏ÏßÄÏ†ï Í≥ºÎ™©",
                    // ÍµêÏàòÎ™ÖÍ≥º Í∞ïÏùòÏã§ Ï†ïÎ≥¥Îäî Ïù¥Î≤§Ìä∏Ïóê Î™ÖÏãúÎêú Í∞íÏù¥ ÏûàÏúºÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ ÏõêÎ≥∏ ÏàòÏóÖ Ï†ïÎ≥¥ ÏÇ¨Ïö©
                    professor_name: e.professor_name || (originalTimetable ? originalTimetable.professor_name : "ÎØ∏ÏßÄÏ†ï ÍµêÏàò"),
                    room: e.room || (originalTimetable ? originalTimetable.room : ""),
                    year: parseInt(e.year),
                    level: e.level,
                    is_foreigner_target: false,
                    description: e.description
                });
            }
        });
        
        // Í≥µÌú¥Ïùº Ï≤òÎ¶¨
        holidays.forEach(h => {
            // Í≥µÌú¥Ïùº ÎÇ†ÏßúÎ°úÎ∂ÄÌÑ∞ ÏöîÏùº Ï∂îÏ∂ú
            const holidayDate = dayjs(h.date);
            const dayOfWeek = holidayDate.day();
            
            // Ïà´Ïûê ÏöîÏùº Ïù∏Îç±Ïä§Î•º ÏöîÏùº Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
            const dayMap = {1: 'Ïõî', 2: 'Ìôî', 3: 'Ïàò', 4: 'Î™©', 5: 'Í∏à'};
            const day = dayMap[dayOfWeek] || null;
            
            if (day) { // ÌèâÏùº Í≥µÌú¥ÏùºÎßå Ï∂îÍ∞Ä
                allEvents.push({
                    id: `holiday-${h.date}`,
                    event_type: 'holiday',
                    event_date: h.date,
                    day: day, // ÏöîÏùº Ï∂îÍ∞Ä
                    title: h.name,
                    subject_name: h.name,
                    description: h.description
                });
            }
        });

        console.log(`Ï¥ù Ïù¥Î≤§Ìä∏ Ïàò: ${allEvents.length}Í∞ú`);
        res.json(allEvents);
    } catch (err) {
        console.error("‚ùå getEvents Ïò§Î•ò:", err);
        res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù" });
    }
};

/**
 * ÌîÑÎ°†Ìä∏ÏóîÎìú Î†àÎ≤® ÏΩîÎìúÎ•º Î∞±ÏóîÎìú Î†àÎ≤® Í∞íÏúºÎ°ú Îß§Ìïë
 * @param {string} frontendLevel - ÌîÑÎ°†Ìä∏ÏóêÏÑú Î∞õÏùÄ Î†àÎ≤® ÏΩîÎìú (Ïòà: 'beginner', 'JLPT3' Îì±)
 * @returns {Array} - DBÏóêÏÑú ÏÇ¨Ïö©ÎêòÎäî Î†àÎ≤® Í∞í Î∞∞Ïó¥ (Ïó¨Îü¨ Í∞í Îß§Ïπ≠ Í∞ÄÎä•)
 */
function mapFrontendLevelToDBLevels(frontendLevel) {
  if (!frontendLevel || frontendLevel === 'ALL') return [];
  
  // Îã§ÏñëÌïú ÎÑ§Ïù¥Î∞ç Ïª®Î≤§ÏÖò ÏßÄÏõêÏùÑ ÏúÑÌïú Îß§Ìïë ÌÖåÏù¥Î∏î
  const levelMap = {
    // JLPT Î†àÎ≤® (ÏßÅÏ†ë Îß§Ìïë)
    'JLPT1': ['JLPT1', 'N1'],
    'JLPT2': ['JLPT2', 'N2'],
    'JLPT3': ['JLPT3', 'N3'],
    'N1': ['N1', 'JLPT1'],
    'N2': ['N2', 'JLPT2'],
    'N3': ['N3', 'JLPT3'],
    
    // TOPIK Î†àÎ≤®
    'TOPIK4': ['TOPIK4'],
    'TOPIK6': ['TOPIK6'],
    
    // ÏàòÏ§ÄÎ≥Ñ Î†àÎ≤® Îß§Ìïë (ÏöîÏ≤≠ÎåÄÎ°ú Íµ¨ÌòÑ)
    'beginner': ['N1', 'N2', 'N3'],
    'intermediate': ['N2', 'N3'],
    'advanced': ['N1']
  };
  
  // Î†àÎ≤® Í∞í Í∞ÄÏ†∏Ïò§Í∏∞
  const mappedLevels = levelMap[frontendLevel] || [frontendLevel];
  
  // ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏ Ï∂îÍ∞Ä
  console.log(`üîÑ Î†àÎ≤® Îß§Ìïë ÌôïÏû•: ${frontendLevel} ‚Üí ${mappedLevels.join(', ')}`);
  
  // Îß§Ìïë Í∞íÏù¥ ÏóÜÎäî Í≤ΩÏö∞ Ï∂îÍ∞Ä Î°úÍπÖ
  if (!levelMap[frontendLevel]) {
    console.warn(`‚ö†Ô∏è Ïïå Ïàò ÏóÜÎäî Î†àÎ≤® ÏΩîÎìú: ${frontendLevel} - ÏõêÎ≥∏ Í∞í Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©`);
  }
  
  return mappedLevels;
}

/**
 * Ï£ºÍ∞Ñ ÏãúÍ∞ÑÌëú Ï°∞Ìöå API
 * /api/timetable/weekly?grade=1&level=JLPT3&group_level=A&is_foreigner=1&student_type=foreigner&semester=spring&week=2023-09-04
 * 
 * Ï£ºÏñ¥ÏßÑ week(ÏõîÏöîÏùº ÎÇ†Ïßú) Í∏∞Ï§ÄÏúºÎ°ú Ìï¥Îãπ Ï£ºÏùò Î™®Îì† Ïù¥Î≤§Ìä∏ Î∞òÌôò
 * - Ï†ïÍ∑úÏàòÏóÖ (grade ÌïÑÌÑ∞, is_special_lecture=0)
 * - ÌäπÍ∞ï (level + group_level ÌïÑÌÑ∞, is_special_lecture=1)
 * - Ìú¥Í∞ï/Î≥¥Í∞ï Ïù¥Î≤§Ìä∏ (timetable_events ÌÖåÏù¥Î∏î)
 * - Í≥µÌú¥Ïùº (holidays ÌÖåÏù¥Î∏î)
 * 
 * ÏöîÏùºÎ≥Ñ + ÍµêÏãúÎ≥ÑÎ°ú Ï†ïÎ†¨Îêú Ïù¥Î≤§Ìä∏ Î∞∞Ïó¥ Î∞òÌôò
 */
exports.getWeeklyTimetable = async (req, res) => {
  const { 
    grade, 
    level, 
    group_level = 'ALL',
    is_foreigner,
    student_type, 
    semester,
    week,
    ignoreGradeFilter = 'false', // ÌäπÍ∞ïÏùò ÌïôÎÖÑ ÌïÑÌÑ∞ÎßÅ Î¨¥Ïãú Ïó¨Î∂Ä
    ignoreLevelFilter = 'false'  // ÌäπÍ∞ïÏùò Î†àÎ≤® ÌïÑÌÑ∞ÎßÅ Î¨¥Ïãú Ïó¨Î∂Ä (Ï∂îÍ∞Ä)
  } = req.query;

  if (!week || !semester) {
    return res.status(400).json({ message: "weekÏôÄ semesterÎäî ÌïÑÏàò ÌååÎùºÎØ∏ÌÑ∞ÏûÖÎãàÎã§." });
  }

  try {
    // 1. Ï£º ÏãúÏûëÏùº(ÏõîÏöîÏùº)Í≥º Ï¢ÖÎ£åÏùº(ÏùºÏöîÏùº) Í≥ÑÏÇ∞
    const weekStart = dayjs(week).startOf('week').add(1, 'day').format('YYYY-MM-DD'); // ÏõîÏöîÏùº
    const weekEnd = dayjs(week).startOf('week').add(7, 'day').format('YYYY-MM-DD');   // ÏùºÏöîÏùº
    
    console.log(`üìÖ Ï£ºÍ∞Ñ Ï°∞Ìöå: ${weekStart} ~ ${weekEnd}`);
    console.log(`üîç Ï°∞Ìöå ÌååÎùºÎØ∏ÌÑ∞: grade=${grade}, level=${level}, group=${group_level}, is_foreigner=${is_foreigner}, semester=${semester}, ignoreGradeFilter=${ignoreGradeFilter}, ignoreLevelFilter=${ignoreLevelFilter}`);

    // 2. ÌïÑÌÑ∞ ÏòµÏÖò Ï≤òÎ¶¨
    const skipGradeFilter = ignoreGradeFilter === 'true' || !grade;
    const skipLevelFilter = ignoreLevelFilter === 'true' || !level || level === 'ALL';
    const ignoreGroupFilter = group_level === 'ALL' || !group_level;
    const isForeigner = is_foreigner === 'true' || is_foreigner === '1';
    
    // Î†àÎ≤® Í∞íÏùÑ DBÏóêÏÑú ÏÇ¨Ïö©ÎêòÎäî Í∞íÏúºÎ°ú Îß§Ìïë
    const dbLevels = mapFrontendLevelToDBLevels(level);
    console.log(`üîÑ Î†àÎ≤® Îß§Ìïë: ${level} ‚Üí ${dbLevels.join(', ') || 'Îß§Ìïë ÏóÜÏùå'}`);
    
    // 3. Ï†ïÍ∑ú ÏàòÏóÖ Ï°∞Ìöå (is_special_lecture=0)
    let regularQuery = `
      SELECT t.*, s.name AS subject_name, 'regular' AS type
      FROM timetables t
      LEFT JOIN subjects s ON t.subject_id = s.id
      WHERE t.semester = ?
        AND t.is_special_lecture = 0
    `;
    
    const regularParams = [semester];
    
    // ÌïôÎÖÑ ÌïÑÌÑ∞ Ï†ÅÏö© (Ï†ïÍ∑ú ÏàòÏóÖ)
    if (!skipGradeFilter) {
      regularQuery += ` AND t.year = ?`;
      regularParams.push(grade);
    }

    // Ïô∏Íµ≠Ïù∏ ÌïÑÌÑ∞ÎßÅÏùÑ ÏúÑÌïú ÏøºÎ¶¨ Ï∂îÍ∞Ä (ÌïúÍµ≠Ïù∏/Ïô∏Íµ≠Ïù∏Ïö© ÏàòÏóÖ Íµ¨Î∂Ñ)
    if (isForeigner) {
      // Ïô∏Íµ≠Ïù∏Ïö© ÏàòÏóÖÏùÄ Ï£ºÎ°ú ÌïúÍµ≠Ïñ¥ Í¥ÄÎ†® ÏàòÏóÖÍ≥º Ï†ÑÍ≥µ ÏàòÏóÖ
      regularQuery += ` AND (s.name LIKE '%ÌïúÍµ≠Ïñ¥%' OR s.name LIKE '%Korean%' OR s.name NOT LIKE '%ÏùºÎ≥∏Ïñ¥%')`;
    } else {
      // ÌïúÍµ≠Ïù∏Ïö© ÏàòÏóÖÏùÄ ÏùºÎ≥∏Ïñ¥ Í¥ÄÎ†® ÏàòÏóÖÏùÑ Ìè¨Ìï®
      regularQuery += ` AND (s.name NOT LIKE '%ÌïúÍµ≠Ïñ¥%' AND s.name NOT LIKE '%Korean%')`;
    }
    
    console.log(`üîç Ï†ïÍ∑ú ÏàòÏóÖ ÏøºÎ¶¨: ${regularQuery}`);
    console.log(`üîç Ï†ïÍ∑ú ÏàòÏóÖ ÌååÎùºÎØ∏ÌÑ∞: ${regularParams}`);
    
    const [regulars] = await pool.query(regularQuery, regularParams);
    console.log(`üìä Ï†ïÍ∑ú ÏàòÏóÖ Ï°∞Ìöå Í≤∞Í≥º: ${regulars.length}Í∞ú`);
    
    // 4. ÌäπÍ∞ï Ï°∞Ìöå (is_special_lecture=1)
    // ÌäπÍ∞ï(N1, N2, N3)ÏùÄ ÌïôÎÖÑÏóê Í¥ÄÍ≥ÑÏóÜÏù¥ level Í∏∞Ï§ÄÏúºÎ°ú Ï°∞ÌöåÌïòÍ≥† ÌëúÏãú
    let specialQuery = `
      SELECT t.*, s.name AS subject_name, 'special' AS type
      FROM timetables t
      LEFT JOIN subjects s ON t.subject_id = s.id
      WHERE t.semester = ?
        AND t.is_special_lecture = 1
    `;
    
    const specialParams = [semester];
    
    // Î†àÎ≤® ÌïÑÌÑ∞ Ï†ÅÏö© (ÌäπÍ∞ï) - Îçî Ïú†Ïó∞Ìïú Ï°∞Í±¥ Ï∂îÍ∞Ä
    if (!skipLevelFilter && dbLevels.length > 0) {
      const placeholders = dbLevels.map(() => '?').join(', ');
      specialQuery += ` AND (t.level IS NULL OR t.level = '' OR t.level IN (${placeholders}))`;
      specialParams.push(...dbLevels);
      console.log(`üîç ÌäπÍ∞ï Î†àÎ≤® ÌïÑÌÑ∞ Ï†ÅÏö©: ${dbLevels.join(', ')} (${dbLevels.length}Í∞ú Í∞í)`);
      console.log(`üîπ ÏÉùÏÑ±Îêú SQL Ï°∞Í±¥: t.level IN (${placeholders})`);
    } else {
      console.log(`üîç ÌäπÍ∞ï Î†àÎ≤® ÌïÑÌÑ∞ ÎØ∏Ï†ÅÏö© (Î™®Îì† ÌäπÍ∞ï Ï°∞Ìöå)`);
    }
    
    // Î∂ÑÎ∞ò ÌïÑÌÑ∞ Ï†ÅÏö© (ÌäπÍ∞ï)
    if (!ignoreGroupFilter) {
      specialQuery += ` AND (t.group_levels IS NULL OR JSON_CONTAINS(t.group_levels, JSON_QUOTE(?)))`;
      specialParams.push(group_level);
    }
    
    console.log(`üîç ÌäπÍ∞ï ÏøºÎ¶¨: ${specialQuery}`);
    console.log(`üîç ÌäπÍ∞ï ÌååÎùºÎØ∏ÌÑ∞: ${specialParams}`);
    
    const [specials] = await pool.query(specialQuery, specialParams);
    console.log(`üìä ÌäπÍ∞ï Ï°∞Ìöå Í≤∞Í≥º: ${specials.length}Í∞ú`);
    
    // ÌäπÍ∞ï Í≤∞Í≥ºÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ Ï∂îÍ∞Ä ÎîîÎ≤ÑÍπÖ
    if (specials.length === 0) {
      console.log(`‚ö†Ô∏è ÌäπÍ∞ï Ï°∞Ìöå Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§. Îçî ÎÑìÏùÄ Ï°∞Í±¥ÏúºÎ°ú Ïû¨ÏãúÎèÑ...`);
      
      // Î™®Îì† ÌäπÍ∞ïÏùÑ Í∞ÄÏ†∏ÏôÄÏÑú Ïã§Ï†ú DB ÎÇ¥Ïö© ÌôïÏù∏
      const [allSpecials] = await pool.query(`
        SELECT t.id, t.level, t.semester, t.group_levels, s.name AS subject_name
        FROM timetables t
        LEFT JOIN subjects s ON t.subject_id = s.id
        WHERE t.is_special_lecture = 1
        LIMIT 5
      `);
      
      if (allSpecials.length > 0) {
        console.log(`üí° DBÏóêÏÑú ÌôïÏù∏Îêú ÌäπÍ∞ï ÏÉòÌîå Îç∞Ïù¥ÌÑ∞ (Ï¥ù ${allSpecials.length}Í∞ú):`);
        allSpecials.forEach((s, i) => {
          console.log(`  ÌäπÍ∞ï #${i+1}: id=${s.id}, level=${s.level || 'NULL'}, subject=${s.subject_name || 'NULL'}, group_levels=${s.group_levels || 'NULL'}`);
        });
      } else {
        console.log(`‚ùó DBÏóê ÌäπÍ∞ï Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.`);
      }
    }
    
    // Î™®Îì† ÌäπÍ∞ï Ï°∞ÌöåÎ•º ÏúÑÌïú ÎîîÎ≤ÑÍπÖ ÏΩîÎìú Ï∂îÍ∞Ä
    if (skipLevelFilter) {
      console.log(`üí° ignoreLevelFilter=${ignoreLevelFilter}, Î™®Îì† ÌäπÍ∞ï Ï°∞Ìöå Î™®Îìú ÌôúÏÑ±Ìôî`);
    }
    
    // 5. Î≥¥Í∞ï/Ìú¥Í∞ï Ïù¥Î≤§Ìä∏ Ï°∞Ìöå - ÏÑ†ÌÉùÌïú weekÏóê ÎßûÍ≤å Ïù¥Î≤§Ìä∏ ÌïÑÌÑ∞ÎßÅ Í∞ïÌôî
    let eventsQuery = `
      SELECT 
        e.*, 
        s.name AS subject_name, 
        e.event_type AS type, 
        t.year as timetable_year,
        t.is_special_lecture,
        t.level as timetable_level,
        t.professor_name AS inherited_professor_name,
        t.room AS inherited_room,
        CASE 
          WHEN e.inherit_attributes = 1 AND t.professor_name IS NOT NULL THEN t.professor_name 
          ELSE NULL
        END AS professor_name,
        CASE 
          WHEN e.inherit_attributes = 1 AND t.room IS NOT NULL THEN t.room
          ELSE NULL
        END AS room
      FROM timetable_events e
      LEFT JOIN subjects s ON e.subject_id = s.id
      LEFT JOIN timetables t ON e.timetable_id = t.id
      WHERE e.event_date BETWEEN ? AND ?
    `;

    let eventsParams = [weekStart, weekEnd];

    // üöß ÌïôÎÖÑ ÌïÑÌÑ∞ÎßÅ Í∞úÏÑ† üöß
    // ÌäπÍ∞ï ÏàòÏóÖ(is_special_lecture = 1)ÏùÄ ÌïôÎÖÑ ÌïÑÌÑ∞Î•º Î¨¥ÏãúÌïòÍ≥† levelÎ°ú ÌïÑÌÑ∞ÎßÅ
    // Ï†ïÍ∑ú ÏàòÏóÖ(is_special_lecture = 0)ÏùÄ ÌïôÎÖÑ(year)ÏúºÎ°ú ÌïÑÌÑ∞ÎßÅ
    if (!skipGradeFilter) {
      eventsQuery += ` AND (
        (t.is_special_lecture = 0 AND (t.year = ? OR e.year = ?)) OR 
        (t.is_special_lecture = 1) OR
        (t.is_special_lecture IS NULL AND (e.year = ? OR e.year IS NULL))
      )`;
      eventsParams.push(grade, grade, grade);
    }

    // Î†àÎ≤® ÌïÑÌÑ∞ÎßÅ (ÌäπÍ∞ï ÎåÄÏÉÅ)
    if (!skipLevelFilter && dbLevels.length > 0) {
      const placeholders = dbLevels.map(() => '?').join(', ');
      eventsQuery += ` AND (
        t.is_special_lecture = 0 OR 
        t.is_special_lecture IS NULL OR
        (t.is_special_lecture = 1 AND (t.level IS NULL OR t.level = '' OR t.level IN (${placeholders})))
      )`;
      eventsParams.push(...dbLevels);
      console.log(`üîç Ïù¥Î≤§Ìä∏ Î†àÎ≤® ÌïÑÌÑ∞ Ï†ÅÏö©: ${dbLevels.join(', ')} (${dbLevels.length}Í∞ú Í∞í)`);
      console.log(`üîπ Ïù¥Î≤§Ìä∏ SQL Ï°∞Í±¥: t.level IN (${placeholders})`);
    }

    // Query Ïã§Ìñâ - Ïù¥Î≤§Ìä∏ Í≤ÄÏÉâ
    console.log(`üîç Ïù¥Î≤§Ìä∏ ÏøºÎ¶¨ Ïã§Ìñâ: ${eventsQuery}`);
    console.log(`üî¢ Ïù¥Î≤§Ìä∏ ÌååÎùºÎØ∏ÌÑ∞:`, eventsParams);

    const [events] = await pool.query(eventsQuery, eventsParams);
    console.log(`üìä Ï°∞ÌöåÎêú Ïù¥Î≤§Ìä∏ Ïàò: ${events.length}Í∞ú`);
    
    // ÏÉÅÏÜç Í¥ÄÎ†® ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏
    const inheritEvents = events.filter(e => e.inherit_attributes === 1);
    console.log(`üë®‚Äçüè´ ÏÉÅÏÜç ÏÜçÏÑ±(inherit_attributes=1) Ïù¥Î≤§Ìä∏: ${inheritEvents.length}Í∞ú`);
    
    if (inheritEvents.length > 0) {
      // Ï≤´ Î≤àÏß∏ ÏÉÅÏÜç Ïù¥Î≤§Ìä∏ ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ï∂úÎ†•
      const sampleEvent = inheritEvents[0];
      console.log('üìå ÏÉÅÏÜç Ïù¥Î≤§Ìä∏ ÏÉòÌîå:', {
        id: sampleEvent.id,
        event_type: sampleEvent.event_type,
        timetable_id: sampleEvent.timetable_id,
        inherit_attributes: sampleEvent.inherit_attributes,
        professor_name: sampleEvent.professor_name,
        inherited_professor_name: sampleEvent.inherited_professor_name,
        room: sampleEvent.room,
        inherited_room: sampleEvent.inherited_room
      });
    }
    
    // ÏÉÅÏÜç Ïã§Ìå® Ïù¥Î≤§Ìä∏ (inherit_attributes=1Ïù¥ÏßÄÎßå ÏÉÅÏÜç Í∞íÏù¥ nullÏù∏ Í≤ΩÏö∞)
    const failedInheritEvents = events.filter(e => 
      e.inherit_attributes === 1 && 
      (e.inherited_professor_name === null || e.inherited_room === null)
    );
    
    if (failedInheritEvents.length > 0) {
      console.warn(`‚ö†Ô∏è ÏÉÅÏÜç Ïã§Ìå® Ïù¥Î≤§Ìä∏: ${failedInheritEvents.length}Í∞ú`);
      console.warn('Ï≤´ Î≤àÏß∏ Ïã§Ìå® Ïù¥Î≤§Ìä∏:', failedInheritEvents[0]);
    }
    
    // 6. Í≥µÌú¥Ïùº Ï°∞Ìöå - ÏÑ†ÌÉùÌïú weekÏóê ÎßûÍ≤å Í≥µÌú¥Ïùº ÌïÑÌÑ∞ÎßÅ
    const holidays = await getPublicHolidaysInRangeWithFallback(weekStart, weekEnd);
    console.log(`üìä Í≥µÌú¥Ïùº Ï°∞Ìöå Í≤∞Í≥º: ${holidays.length}Í∞ú`);
    
    const formattedHolidays = holidays.map(h => ({
      ...h,
      type: 'holiday',
      title: h.name || 'Í≥µÌú¥Ïùº',
      date: h.date,
      color: '#ef4444', // Ìú¥Ïùº ÏÉâÏÉÅ (Îπ®Í∞ÑÏÉâ)
      start_period: '1', // Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
      end_period: '9',   // Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
      id: `holiday-${h.date || new Date().toISOString()}`
    }));
    
    // 7. ÍµêÏãúÎ≥Ñ ÏãúÍ∞Ñ Îß§Ìïë 
    const periodMap = await getPeriodMap();
    
    // 8. Ï†ïÍ∑ú ÏàòÏóÖÏùÑ Ï£ºÍ∞Ñ ÎÇ†ÏßúÎ°ú ÌôïÏû•
    const expandedRegulars = [];
    for (const item of regulars) {
      // Í∏∞Î≥∏Í∞í ÏÑ§Ï†ïÌï¥ item Î≥¥Í∞ï
      const safeItem = {
        ...item,
        subject_name: item.subject_name || "ÎØ∏ÏßÄÏ†ï Í≥ºÎ™©",
        professor_name: item.professor_name || "ÎØ∏ÏßÄÏ†ï ÍµêÏàò",
        start_period: item.start_period || "1",
        end_period: item.end_period || "1",
        day: item.day || "Ïõî", // ÏöîÏùº Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
      };

      try {
        const dates = expandTimetableToDates(safeItem, weekStart, weekEnd);
        for (const expandedItem of dates) {
          expandedRegulars.push({
            ...expandedItem,
            id: item.id || `regular-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
            subject_name: expandedItem.subject_name || "ÎØ∏ÏßÄÏ†ï Í≥ºÎ™©",
            title: expandedItem.subject_name || "ÎØ∏ÏßÄÏ†ï Í≥ºÎ™©",
            professor: expandedItem.professor_name || "ÎØ∏ÏßÄÏ†ï ÍµêÏàò",
            type: 'regular',
            start_time: periodMap[expandedItem.start_period]?.start_time || "09:00",
            end_time: periodMap[expandedItem.end_period]?.end_time || "18:00",
            color: '#3b82f6', // Ï†ïÍ∑ú ÏàòÏóÖ ÏÉâÏÉÅ (ÌååÎûÄÏÉâ)
            start_period: expandedItem.start_period || "1",
            end_period: expandedItem.end_period || "1",
            year: item.year // ÌïôÎÖÑ Ï†ïÎ≥¥ Î™ÖÏãúÏ†ÅÏúºÎ°ú Ï∂îÍ∞Ä
          });
        }
      } catch (err) {
        console.error(`‚ùå Ï†ïÍ∑ú ÏàòÏóÖ ÌôïÏû• Ï§ë Ïò§Î•ò:`, err, safeItem);
      }
    }
    
    // 9. ÌäπÍ∞ïÏùÑ Ï£ºÍ∞Ñ ÎÇ†ÏßúÎ°ú ÌôïÏû• - ÌäπÍ∞ïÏùÄ ÌïôÎÖÑÏóê Í¥ÄÍ≥ÑÏóÜÏù¥ ÌëúÏãú
    const expandedSpecials = [];
    for (const item of specials) {
      // Í∏∞Î≥∏Í∞í ÏÑ§Ï†ïÌï¥ item Î≥¥Í∞ï
      const safeItem = {
        ...item,
        subject_name: item.subject_name || "ÎØ∏ÏßÄÏ†ï ÌäπÍ∞ï",
        professor_name: item.professor_name || "ÎØ∏ÏßÄÏ†ï ÍµêÏàò",
        start_period: item.start_period || "1",
        end_period: item.end_period || "1",
        day: item.day || "Ïõî", // ÏöîÏùº Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
      };

      try {
        const dates = expandTimetableToDates(safeItem, weekStart, weekEnd);
        for (const expandedItem of dates) {
          expandedSpecials.push({
            ...expandedItem,
            id: item.id || `special-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
            subject_name: expandedItem.subject_name || "ÎØ∏ÏßÄÏ†ï ÌäπÍ∞ï",
            title: expandedItem.subject_name || "ÎØ∏ÏßÄÏ†ï ÌäπÍ∞ï",
            professor: expandedItem.professor_name || "ÎØ∏ÏßÄÏ†ï ÍµêÏàò",
            type: 'special',
            start_time: periodMap[expandedItem.start_period]?.start_time || "09:00",
            end_time: periodMap[expandedItem.end_period]?.end_time || "18:00",
            color: '#10b981', // ÌäπÍ∞ï ÏÉâÏÉÅ (ÎÖπÏÉâ)
            start_period: expandedItem.start_period || "1",
            end_period: expandedItem.end_period || "1",
            level: item.level // Î†àÎ≤® Ï†ïÎ≥¥ Î™ÖÏãúÏ†ÅÏúºÎ°ú Ï∂îÍ∞Ä
          });
        }
      } catch (err) {
        console.error(`‚ùå ÌäπÍ∞ï ÌôïÏû• Ï§ë Ïò§Î•ò:`, err, safeItem);
      }
    }
    
    // 10. Î≥¥Í∞ï/Ìú¥Í∞ï Ïù¥Î≤§Ìä∏ Ìè¨Îß∑ÌåÖ - Ïù¥Î≤§Ìä∏ ÎÇ†Ïßú ÌïÑÌÑ∞ÎßÅ Í∞ïÌôî
    const formattedEvents = events
      .filter(event => {
        // event_dateÍ∞Ä weekStartÏôÄ weekEnd ÏÇ¨Ïù¥Ïóê ÏûàÎäîÏßÄ ÌôïÏù∏
        const eventDate = dayjs(event.event_date);
        const isInRange = (
          eventDate.isAfter(dayjs(weekStart).subtract(1, 'day')) && 
          eventDate.isBefore(dayjs(weekEnd).add(1, 'day'))
        );
        
        // ÎÇ†Ïßú Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇú Ïù¥Î≤§Ìä∏ Î°úÍπÖ
        if (!isInRange) {
          console.log(`‚è© ÎÇ†Ïßú Î≤îÏúÑ Î∞ñ Ïù¥Î≤§Ìä∏ Ï†úÏô∏: id=${event.id}, ÎÇ†Ïßú=${event.event_date}, Î≤îÏúÑ=${weekStart}~${weekEnd}`);
          return false;
        }
        
        return isInRange;
      })
      .map(event => {
        try {
          // event_date Ï≤òÎ¶¨ - Date Í∞ùÏ≤¥ ÎòêÎäî ÎÇ†Ïßú Î¨∏ÏûêÏó¥ÏùÑ ÌÜµÏùºÎêú ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
          let formattedDate = event.event_date;
          if (event.event_date instanceof Date) {
            formattedDate = dayjs(event.event_date).format('YYYY-MM-DD');
          } else if (typeof event.event_date === 'string' && event.event_date.includes('T')) {
            // ISO date format or other date string with time component
            formattedDate = dayjs(event.event_date).format('YYYY-MM-DD');
          }

          // ÍµêÏàòÎ™ÖÍ≥º Í∞ïÏùòÏã§ Ï≤òÎ¶¨ - inherit_attributesÍ∞Ä 1Ïù¥Î©¥ timetableÏóêÏÑú ÏÉÅÏÜç
          const effectiveProfessorName = (event.inherit_attributes === 1 && event.inherited_professor_name) 
            ? event.inherited_professor_name 
            : (event.professor_name || "ÎØ∏ÏßÄÏ†ï ÍµêÏàò");
          
          const effectiveRoom = (event.inherit_attributes === 1 && event.inherited_room) 
            ? event.inherited_room 
            : (event.room || "");
          
          return {
            ...event,
            id: event.id || `event-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
            subject_name: event.subject_name || (event.type === 'cancel' ? 'Ìú¥Í∞ï' : 'Î≥¥Í∞ï'),
            title: event.subject_name || (event.type === 'cancel' ? 'Ìú¥Í∞ï' : 'Î≥¥Í∞ï'),
            color: event.type === 'cancel' 
              ? '#9ca3af'  // Ìú¥Í∞ï ÏÉâÏÉÅ (ÌöåÏÉâ)
              : '#f59e0b', // Î≥¥Í∞ï ÏÉâÏÉÅ (Ï£ºÌô©ÏÉâ)
            start_time: periodMap[event.start_period]?.start_time || "09:00",
            end_time: periodMap[event.end_period]?.end_time || "18:00",
            start_period: event.start_period || "1",
            end_period: event.end_period || "1",
            professor: effectiveProfessorName,
            professor_name: effectiveProfessorName,
            room: effectiveRoom,
            date: formattedDate,
            inherit_attributes: event.inherit_attributes,
            inherited_professor_name: event.inherited_professor_name || null,
            inherited_room: event.inherited_room || null
          };
        } catch (err) {
          console.error(`‚ùå Ïù¥Î≤§Ìä∏ Ìè¨Îß∑ÌåÖ Ï§ë Ïò§Î•ò:`, err, event);
          // Ïò§Î•ò Î∞úÏÉù Ïãú ÏµúÏÜåÌïúÏùò Îç∞Ïù¥ÌÑ∞Î°ú Î∞òÌôò
          return {
            ...event,
            id: event.id || `event-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
            subject_name: "Ïù¥Î≤§Ìä∏",
            title: "Ïù¥Î≤§Ìä∏",
            start_period: "1",
            end_period: "1",
            professor_name: (event.inherit_attributes === 1 && event.inherited_professor_name) 
              ? event.inherited_professor_name 
              : "ÎØ∏ÏßÄÏ†ï ÍµêÏàò",
            professor: (event.inherit_attributes === 1 && event.inherited_professor_name) 
              ? event.inherited_professor_name 
              : "ÎØ∏ÏßÄÏ†ï ÍµêÏàò",
            room: (event.inherit_attributes === 1 && event.inherited_room) 
              ? event.inherited_room 
              : "",
            color: '#9ca3af',
            date: event.event_date || weekStart,
            inherited_professor_name: event.inherited_professor_name || null,
            inherited_room: event.inherited_room || null
          };
        }
      });
    
    // 11. Î™®Îì† Ïù¥Î≤§Ìä∏ Î≥ëÌï©
    const allEvents = [
      ...expandedRegulars,
      ...expandedSpecials,
      ...formattedEvents,
      ...formattedHolidays
    ];
    
    // Îç∞Ïù¥ÌÑ∞ Î¨¥Í≤∞ÏÑ± Í≤ÄÏÇ¨ - IDÏôÄ ÎÇ†Ïßú ÌïÑÎìú ÌôïÏù∏
    allEvents.forEach((event, index) => {
      if (!event.id) {
        console.warn(`‚ö†Ô∏è IDÍ∞Ä ÏóÜÎäî Ïù¥Î≤§Ìä∏ Î∞úÍ≤¨ [${index}]:`, event);
        event.id = `generated-${Date.now()}-${index}`; // ID ÏÉùÏÑ±
      }
      
      if (!event.date) {
        console.warn(`‚ö†Ô∏è ÎÇ†ÏßúÍ∞Ä ÏóÜÎäî Ïù¥Î≤§Ìä∏ Î∞úÍ≤¨ [${index}]:`, event);
        // ÏöîÏùº Ï†ïÎ≥¥Í∞Ä ÏûàÏúºÎ©¥ Ìï¥Îãπ Ï£ºÏùò ÏöîÏùºÎ°ú ÎÇ†Ïßú ÏÉùÏÑ±
        if (event.day) {
          const dayMap = {'Ïõî': 1, 'Ìôî': 2, 'Ïàò': 3, 'Î™©': 4, 'Í∏à': 5, 'ÌÜ†': 6, 'Ïùº': 0};
          const dayIndex = dayMap[event.day];
          if (dayIndex !== undefined) {
            const dayDate = dayjs(weekStart).day(dayIndex).format('YYYY-MM-DD');
            event.date = dayDate;
            console.log(`üîß ÏöîÏùº(${event.day})Ïóê ÎßûÍ≤å ÎÇ†Ïßú(${dayDate}) ÏÉùÏÑ±Ìï®`);
          } else {
            event.date = weekStart; // Í∏∞Î≥∏Í∞í
          }
        } else {
          event.date = weekStart; // Í∏∞Î≥∏Í∞í
        }
      }
    });

    // Îç∞Ïù¥ÌÑ∞ ÏïàÏ†ÑÏÑ± Í≤ÄÏ¶ù Î°úÍ∑∏
    const problematicEvents = allEvents.filter(
      event => !event.title || !event.date || !event.start_period || event.start_period === undefined
    );

    if (problematicEvents.length > 0) {
      console.warn(`‚ö†Ô∏è ÎàÑÎùΩÎêú ÌïÑÎìúÍ∞Ä ÏûàÎäî Ïù¥Î≤§Ìä∏ ${problematicEvents.length}Í∞ú Î∞úÍ≤¨:`, 
        problematicEvents.map(e => ({ id: e.id, title: e.title, date: e.date, start_period: e.start_period }))
      );
    }

    // Ï†ïÎ†¨ Ï†Ñ ÎÇ†Ïßú ÌïÑÎìú Ï≤¥ÌÅ¨ Î∞è Î°úÍ∑∏
    console.log(`üîç Ï†ïÎ†¨ Ï†Ñ ÎÇ†Ïßú ÌïÑÎìú ÏÉòÌîå ÌôïÏù∏ (Ï≤òÏùå 5Í∞ú):`);
    allEvents.slice(0, 5).forEach((event, i) => {
      console.log(`  Ïù¥Î≤§Ìä∏ ${i+1}: id=${event.id}, date=${event.date}, type=${event.type}`);
    });

    // 12. Ïù¥Î≤§Ìä∏ Ï†ïÎ†¨ (ÎÇ†Ïßú > ÏöîÏùº > ÍµêÏãú > Ïö∞ÏÑ†ÏàúÏúÑ)
    // Ïö∞ÏÑ†ÏàúÏúÑ: holiday > cancel > makeup > special > regular
    let sortedEvents = [];

    try {
      // Ï†ïÎ†¨ Ï†Ñ Îç∞Ïù¥ÌÑ∞ Î≥µÏÇ¨ Î∞è ÎÇ†Ïßú ÌïÑÎìú Î¨∏ÏûêÏó¥Ìôî
      const safeEvents = allEvents.map(event => ({
        ...event,
        // Î™®Îì† ÌïµÏã¨ ÌïÑÎìúÏóê ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞í Ï†ÅÏö©
        date: typeof event.date === 'string' ? event.date : (
          event.date instanceof Date ? event.date.toISOString().split('T')[0] : weekStart
        ),
        start_period: String(event.start_period || '1'),
        type: event.type || 'event'
      }));
      
      sortedEvents = safeEvents.sort((a, b) => {
        try {
          // 1) ÎÇ†Ïßú Í∏∞Ï§Ä Ï†ïÎ†¨ (ÏïàÏ†ÑÌïòÍ≤å Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò)
          const dateA = String(a.date || '');
          const dateB = String(b.date || '');
          
          if (dateA !== dateB) {
            try {
              return dateA.localeCompare(dateB);
            } catch (err) {
              console.error(`‚ùå ÎÇ†Ïßú ÎπÑÍµê Ïò§Î•ò(${dateA} vs ${dateB}):`, err);
              return 0; // Ïò§Î•ò Ïãú ÎèôÎì± Ï≤òÎ¶¨
            }
          }
          
          // 2) ÍµêÏãú Í∏∞Ï§Ä Ï†ïÎ†¨ (ÏïàÏ†ÑÌïòÍ≤å Ïà´ÏûêÎ°ú Î≥ÄÌôò)
          let startA, startB;
          try {
            startA = parseInt(String(a.start_period || '0')) || 0;
          } catch (err) {
            console.error(`‚ùå ÍµêÏãú ÌååÏã± Ïò§Î•ò(A):`, a.start_period, err);
            startA = 0;
          }
          
          try {
            startB = parseInt(String(b.start_period || '0')) || 0;
          } catch (err) {
            console.error(`‚ùå ÍµêÏãú ÌååÏã± Ïò§Î•ò(B):`, b.start_period, err);
            startB = 0;
          }
          
          if (startA !== startB) {
            return startA - startB;
          }
          
          // 3) ÌÉÄÏûÖ Ïö∞ÏÑ†ÏàúÏúÑ Í∏∞Ï§Ä Ï†ïÎ†¨
          const priorityMap = {
            'holiday': 0,
            'cancel': 1,
            'makeup': 2,
            'special': 3,
            'regular': 4
          };
          
          const priorityA = priorityMap[String(a.type)] !== undefined ? priorityMap[String(a.type)] : 99;
          const priorityB = priorityMap[String(b.type)] !== undefined ? priorityMap[String(b.type)] : 99;
          
          return priorityA - priorityB;
        } catch (sortErr) {
          console.error("‚ùå Ïù¥Î≤§Ìä∏ Ï†ïÎ†¨ Ï§ë Ïò§Î•ò:", sortErr, { 
            a: { id: a.id, title: a.title, date: a.date, start_period: a.start_period, type: a.type },
            b: { id: b.id, title: b.title, date: b.date, start_period: b.start_period, type: b.type }
          });
          return 0; // Ïò§Î•ò Ïãú ÏàúÏÑú Ïú†ÏßÄ
        }
      });
    } catch (sortError) {
      console.error("‚ùå Ïù¥Î≤§Ìä∏ Î∞∞Ïó¥ Ï†ïÎ†¨ Ï§ë Ïò§Î•ò:", sortError, {
        eventsLength: allEvents.length,
        sampleEvent: allEvents.length > 0 ? allEvents[0] : null
      });
      
      // Ï†ïÎ†¨ Ïã§Ìå® Ïãú ÎÇ†Ïßú ÌïÑÎìúÎßå Î¨∏ÏûêÏó¥ Ï≤òÎ¶¨ ÌõÑ Ïû¨ÏãúÎèÑ
      try {
        console.log("üîÑ ÏïàÏ†Ñ Î™®ÎìúÎ°ú Ï†ïÎ†¨ Ïû¨ÏãúÎèÑ...");
        sortedEvents = allEvents.map(e => ({
          ...e,
          date: String(e.date || weekStart),
          start_period: String(e.start_period || '1'),
          type: String(e.type || 'event')
        }));
      } catch (fallbackError) {
        console.error("‚ùå ÏïàÏ†Ñ Î™®Îìú Ï†ïÎ†¨ÎèÑ Ïã§Ìå®:", fallbackError);
        // Î™®Îì† Ï†ïÎ†¨ Ïã§Ìå® Ïãú ÏõêÎ≥∏ Î∞∞Ïó¥ Ïú†ÏßÄ
        sortedEvents = allEvents;
      }
    }

    // 13. ÏµúÏ¢Ö Í≤∞Í≥º Î∞òÌôò
    console.log(`üî¢ Ï£ºÍ∞Ñ Ïù¥Î≤§Ìä∏ Ìï©Í≥Ñ: Ï†ïÍ∑ú(${expandedRegulars.length}), ÌäπÍ∞ï(${expandedSpecials.length}), Ïù¥Î≤§Ìä∏(${formattedEvents.length}), Í≥µÌú¥Ïùº(${formattedHolidays.length})`);

    // ÎßàÏßÄÎßâ ÏïàÏ†Ñ Í≤ÄÏÇ¨ - Ï†ïÎ†¨Îêú Í≤∞Í≥ºÏùò ÎÇ†Ïßú Ï≤¥ÌÅ¨
    sortedEvents.forEach((event, index) => {
      if (!event.date) {
        console.warn(`‚ö†Ô∏è Ï†ïÎ†¨ ÌõÑ ÎÇ†Ïßú ÌïÑÎìú ÏóÜÏùå [${index}]:`, event);
        event.date = weekStart; // Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
      }
    });

    res.json({
      week_start: weekStart,
      week_end: weekEnd,
      events: sortedEvents
    });
  } catch (err) {
    console.error("‚ùå getWeeklyTimetable Ïò§Î•ò:", err);
    res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù" });
  }
};

// ------------------------ CRUD -----------------------

/**
 * ÏãúÍ∞ÑÌëú Îì±Î°ù API
 * POST /api/timetable
 * 
 * Ï†ïÍ∑ú ÏàòÏóÖ ÎòêÎäî ÌäπÍ∞ï ÏÉùÏÑ±ÏùÑ ÏúÑÌïú API
 */
exports.createTimetable = async (req, res) => {
  const {
    year,
    level,
    subject_id,
    day,
    start_period,
    end_period,
    semester,
    room,
    professor_name,
    is_special_lecture,
    group_levels
  } = req.body;
  
  // ÌïÑÏàò ÌïÑÎìú Í≤ÄÏ¶ù
  if (!subject_id || !day || !start_period || !end_period || !semester) {
    return res.status(400).json({ 
      message: "subject_id, day, start_period, end_period, semesterÎäî ÌïÑÏàò ÌïÑÎìúÏûÖÎãàÎã§." 
    });
  }
  
  // ÏöîÏùº Í≤ÄÏ¶ù
  const validDays = ['Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à'];
  if (!validDays.includes(day)) {
    return res.status(400).json({ 
      message: "Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÏöîÏùºÏûÖÎãàÎã§. 'Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à' Ï§ë ÌïòÎÇòÏó¨Ïïº Ìï©ÎãàÎã§." 
    });
  }
  
  // ÍµêÏãú Í≤ÄÏ¶ù
  if (parseInt(start_period) > parseInt(end_period)) {
    return res.status(400).json({ 
      message: "start_periodÎäî end_periodÎ≥¥Îã§ ÏûëÍ±∞ÎÇò Í∞ôÏïÑÏïº Ìï©ÎãàÎã§." 
    });
  }
  
  try {
    // ÏàòÏóÖ ÌÉÄÏûÖÏóê Îî∞Î•∏ ÌïÑÏàò ÌïÑÎìú Í≤ÄÏ¶ù
    const isSpecial = is_special_lecture === 1 || is_special_lecture === '1' || is_special_lecture === true;
    
    if (!isSpecial && !year) {
      return res.status(400).json({ 
        message: "Ï†ïÍ∑ú ÏàòÏóÖ Îì±Î°ù Ïãú year ÌïÑÎìúÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§." 
      });
    }
    
    if (isSpecial && !level) {
      return res.status(400).json({ 
        message: "ÌäπÍ∞ï Îì±Î°ù Ïãú level ÌïÑÎìúÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§." 
      });
    }
    
    // Ï§ëÎ≥µ ÏãúÍ∞ÑÌëú ÌôïÏù∏
    let overlapQuery = `
      SELECT * FROM timetables
      WHERE semester = ?
        AND day = ?
        AND ((start_period <= ? AND end_period >= ?) OR
             (start_period <= ? AND end_period >= ?) OR
             (start_period >= ? AND end_period <= ?))
    `;
    
    const overlapParams = [
      semester,
      day,
      end_period, start_period,    // ÏºÄÏù¥Ïä§ 1: Í∏∞Ï°¥ ÏàòÏóÖÏù¥ ÏÉà ÏàòÏóÖÏùÑ Ìè¨Ìï®
      start_period, start_period,  // ÏºÄÏù¥Ïä§ 2: Í∏∞Ï°¥ ÏàòÏóÖ ÏãúÏûëÏù¥ ÏÉà ÏàòÏóÖ ÏãúÍ∞Ñ ÎÇ¥
      end_period, end_period,      // ÏºÄÏù¥Ïä§ 3: Í∏∞Ï°¥ ÏàòÏóÖ Ï¢ÖÎ£åÍ∞Ä ÏÉà ÏàòÏóÖ ÏãúÍ∞Ñ ÎÇ¥
      start_period, end_period     // ÏºÄÏù¥Ïä§ 4: ÏÉà ÏàòÏóÖÏù¥ Í∏∞Ï°¥ ÏàòÏóÖÏùÑ Ìè¨Ìï®
    ];
    
    // Í∞ôÏùÄ Í≥ºÎ™©ÏùÑ Ï†úÏô∏ÌïòÎ†§Î©¥ subject_idÎ°ú Ï∂îÍ∞Ä ÌïÑÌÑ∞ÎßÅ
    if (subject_id) {
      overlapQuery += ` AND subject_id <> ?`;
      overlapParams.push(subject_id);
    }
    
    // Ï†ïÍ∑úÏàòÏóÖ/ÌäπÍ∞ï Íµ¨Î∂Ñ
    overlapQuery += ` AND is_special_lecture = ?`;
    overlapParams.push(isSpecial ? 1 : 0);
    
    // ÌïôÎÖÑ/Î†àÎ≤® ÌïÑÌÑ∞ÎßÅ Ï∂îÍ∞Ä
    if (!isSpecial && year) {
      overlapQuery += ` AND year = ?`;
      overlapParams.push(year);
    }
    
    if (isSpecial && level) {
      overlapQuery += ` AND level = ?`;
      overlapParams.push(level);
    }
    
    const [overlaps] = await pool.query(overlapQuery, overlapParams);
    
    if (overlaps.length > 0) {
      const overlapInfo = overlaps.map(o => ({
        id: o.id,
        subject_id: o.subject_id,
        day: o.day,
        period: `${o.start_period}-${o.end_period}ÍµêÏãú`
      }));
      
      return res.status(409).json({ 
        message: "Ìï¥Îãπ ÏöîÏùºÍ≥º ÏãúÍ∞ÑÏóê Ï§ëÎ≥µÎêú ÏàòÏóÖÏù¥ ÏûàÏäµÎãàÎã§.",
        conflicts: overlapInfo
      });
    }
    
    // group_levelsÍ∞Ä Î¨∏ÏûêÏó¥Î°ú Îì§Ïñ¥Ïò® Í≤ΩÏö∞ Ï≤òÎ¶¨
    let parsedGroupLevels = group_levels;
    if (typeof group_levels === 'string') {
      try {
        parsedGroupLevels = JSON.parse(group_levels);
      } catch (e) {
        parsedGroupLevels = [group_levels]; // Î¨∏ÏûêÏó¥ ÌïòÎÇòÎ•º Î∞∞Ïó¥Î°ú Î≥ÄÌôò
      }
    }
    
    // DBÏóê ÏãúÍ∞ÑÌëú Ï†ÄÏû•
    const [result] = await pool.query(
      `INSERT INTO timetables (
        year, level, subject_id, day, start_period, end_period, semester,
        room, professor_name, is_special_lecture, group_levels, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
      [
        year || null,
        level || null,
        subject_id,
        day,
        start_period,
        end_period,
        semester,
        room || null,
        professor_name || null,
        isSpecial ? 1 : 0,
        parsedGroupLevels ? JSON.stringify(parsedGroupLevels) : null
      ]
    );
    
    // ÏÉàÎ°ú ÏÉùÏÑ±Îêú ÏãúÍ∞ÑÌëú Ï†ïÎ≥¥ Ï°∞Ìöå
    const [newTimetable] = await pool.query(
      `SELECT t.*, s.name AS subject_name 
       FROM timetables t
       LEFT JOIN subjects s ON t.subject_id = s.id
       WHERE t.id = ?`,
      [result.insertId]
    );
    
    // ÍµêÏãú -> ÏãúÍ∞Ñ Îß§Ìïë Ï∂îÍ∞Ä
    const periodMap = await getPeriodMap();
    const formatted = {
      ...newTimetable[0],
      subject_name: newTimetable[0].subject_name || "ÎØ∏ÏßÄÏ†ï Í≥ºÎ™©",
      start_time: periodMap[newTimetable[0].start_period]?.start_time || "09:00",
      end_time: periodMap[newTimetable[0].end_period]?.end_time || "18:00"
    };
    
    // Í≤∞Í≥º Î∞òÌôò
    res.status(201).json({
      message: isSpecial ? "ÌäπÍ∞ï Îì±Î°ù ÏÑ±Í≥µ" : "Ï†ïÍ∑ú ÏàòÏóÖ Îì±Î°ù ÏÑ±Í≥µ",
      timetable: formatted
    });
    
  } catch (err) {
    console.error("‚ùå createTimetable Ïò§Î•ò:", err);
    res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù", error: err.message });
  }
};

/**
 * ÏãúÍ∞ÑÌëú ÏàòÏ†ï API
 * PUT /api/timetable/:id
 * 
 * Ï†ïÍ∑ú ÏàòÏóÖ ÎòêÎäî ÌäπÍ∞ï ÏàòÏ†ïÏùÑ ÏúÑÌïú API
 */
exports.updateTimetable = async (req, res) => {
  const { id } = req.params;
  const {
    year,
    level,
    subject_id,
    day,
    start_period,
    end_period,
    semester,
    room,
    professor_name,
    is_special_lecture,
    group_levels
  } = req.body;
  
  if (!id) return res.status(400).json({ message: "IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§." });
  
  try {
    // ÏãúÍ∞ÑÌëú Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏
    const [existingRows] = await pool.query("SELECT * FROM timetables WHERE id = ?", [id]);
    if (existingRows.length === 0) {
      return res.status(404).json({ message: "ÏàòÏ†ïÌï† ÏàòÏóÖÏù¥ ÏóÜÏäµÎãàÎã§." });
    }
    
    const existing = existingRows[0];
    
    // ÏàòÏ†ïÌï† ÌïÑÎìú Íµ¨ÏÑ±
    const updates = [];
    const params = [];
    
    if (year !== undefined) {
      updates.push("year = ?");
      params.push(year);
    }
    
    if (level !== undefined) {
      updates.push("level = ?");
      params.push(level);
    }
    
    if (subject_id !== undefined) {
      updates.push("subject_id = ?");
      params.push(subject_id);
    }
    
    if (day !== undefined) {
      // ÏöîÏùº Í≤ÄÏ¶ù
      const validDays = ['Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à'];
      if (!validDays.includes(day)) {
        return res.status(400).json({ 
          message: "Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÏöîÏùºÏûÖÎãàÎã§. 'Ïõî', 'Ìôî', 'Ïàò', 'Î™©', 'Í∏à' Ï§ë ÌïòÎÇòÏó¨Ïïº Ìï©ÎãàÎã§." 
        });
      }
      updates.push("day = ?");
      params.push(day);
    }
    
    if (start_period !== undefined) {
      updates.push("start_period = ?");
      params.push(start_period);
    }
    
    if (end_period !== undefined) {
      updates.push("end_period = ?");
      params.push(end_period);
    }
    
    if (semester !== undefined) {
      updates.push("semester = ?");
      params.push(semester);
    }
    
    if (room !== undefined) {
      updates.push("room = ?");
      params.push(room);
    }
    
    if (professor_name !== undefined) {
      updates.push("professor_name = ?");
      params.push(professor_name);
    }
    
    if (is_special_lecture !== undefined) {
      updates.push("is_special_lecture = ?");
      params.push(is_special_lecture === 1 || is_special_lecture === '1' || is_special_lecture === true ? 1 : 0);
    }
    
    if (group_levels !== undefined) {
      // group_levelsÍ∞Ä Î¨∏ÏûêÏó¥Î°ú Îì§Ïñ¥Ïò® Í≤ΩÏö∞ Ï≤òÎ¶¨
      let parsedGroupLevels = group_levels;
      if (typeof group_levels === 'string') {
        try {
          parsedGroupLevels = JSON.parse(group_levels);
        } catch (e) {
          parsedGroupLevels = [group_levels]; // Î¨∏ÏûêÏó¥ ÌïòÎÇòÎ•º Î∞∞Ïó¥Î°ú Î≥ÄÌôò
        }
      }
      
      updates.push("group_levels = ?");
      params.push(parsedGroupLevels ? JSON.stringify(parsedGroupLevels) : null);
    }
    
    // ÏàòÏ†ïÌï† ÎÇ¥Ïö©Ïù¥ ÏóÜÎäî Í≤ΩÏö∞
    if (updates.length === 0) {
      return res.status(400).json({ message: "ÏàòÏ†ïÌï† ÎÇ¥Ïö©Ïù¥ ÏóÜÏäµÎãàÎã§." });
    }
    
    // Ï§ëÎ≥µ ÏãúÍ∞ÑÌëú ÌôïÏù∏ (ÏûêÍ∏∞ ÏûêÏã†ÏùÄ Ï†úÏô∏)
    const updatedStartPeriod = start_period !== undefined ? start_period : existing.start_period;
    const updatedEndPeriod = end_period !== undefined ? end_period : existing.end_period;
    const updatedDay = day !== undefined ? day : existing.day;
    const updatedSemester = semester !== undefined ? semester : existing.semester;
    const updatedIsSpecial = is_special_lecture !== undefined 
      ? (is_special_lecture === 1 || is_special_lecture === '1' || is_special_lecture === true)
      : (existing.is_special_lecture === 1);
    const updatedYear = year !== undefined ? year : existing.year;
    const updatedLevel = level !== undefined ? level : existing.level;
    
    let overlapQuery = `
      SELECT * FROM timetables
      WHERE semester = ?
        AND day = ?
        AND ((start_period <= ? AND end_period >= ?) OR
             (start_period <= ? AND end_period >= ?) OR
             (start_period >= ? AND end_period <= ?))
        AND id <> ?
    `;
    
    const overlapParams = [
      updatedSemester,
      updatedDay,
      updatedEndPeriod, updatedStartPeriod,    // ÏºÄÏù¥Ïä§ 1: Í∏∞Ï°¥ ÏàòÏóÖÏù¥ ÏÉà ÏàòÏóÖÏùÑ Ìè¨Ìï®
      updatedStartPeriod, updatedStartPeriod,  // ÏºÄÏù¥Ïä§ 2: Í∏∞Ï°¥ ÏàòÏóÖ ÏãúÏûëÏù¥ ÏÉà ÏàòÏóÖ ÏãúÍ∞Ñ ÎÇ¥
      updatedEndPeriod, updatedEndPeriod,      // ÏºÄÏù¥Ïä§ 3: Í∏∞Ï°¥ ÏàòÏóÖ Ï¢ÖÎ£åÍ∞Ä ÏÉà ÏàòÏóÖ ÏãúÍ∞Ñ ÎÇ¥
      updatedStartPeriod, updatedEndPeriod,    // ÏºÄÏù¥Ïä§ 4: ÏÉà ÏàòÏóÖÏù¥ Í∏∞Ï°¥ ÏàòÏóÖÏùÑ Ìè¨Ìï®
      id
    ];
    
    // Ï†ïÍ∑úÏàòÏóÖ/ÌäπÍ∞ï Íµ¨Î∂Ñ
    overlapQuery += ` AND is_special_lecture = ?`;
    overlapParams.push(updatedIsSpecial ? 1 : 0);
    
    // ÌïôÎÖÑ/Î†àÎ≤® ÌïÑÌÑ∞ÎßÅ Ï∂îÍ∞Ä
    if (!updatedIsSpecial && updatedYear) {
      overlapQuery += ` AND year = ?`;
      overlapParams.push(updatedYear);
    }
    
    if (updatedIsSpecial && updatedLevel) {
      overlapQuery += ` AND level = ?`;
      overlapParams.push(updatedLevel);
    }
    
    const [overlaps] = await pool.query(overlapQuery, overlapParams);
    
    if (overlaps.length > 0) {
      const overlapInfo = overlaps.map(o => ({
        id: o.id,
        subject_id: o.subject_id,
        day: o.day,
        period: `${o.start_period}-${o.end_period}ÍµêÏãú`
      }));
      
      return res.status(409).json({ 
        message: "Ìï¥Îãπ ÏöîÏùºÍ≥º ÏãúÍ∞ÑÏóê Ï§ëÎ≥µÎêú ÏàòÏóÖÏù¥ ÏûàÏäµÎãàÎã§.",
        conflicts: overlapInfo
      });
    }
    
    // ÏóÖÎç∞Ïù¥Ìä∏ ÏøºÎ¶¨ Ïã§Ìñâ
    const updateQuery = `UPDATE timetables SET ${updates.join(', ')}, updated_at = NOW() WHERE id = ?`;
    params.push(id);
    
    const [result] = await pool.query(updateQuery, params);
    
    if (result.affectedRows === 0) {
      return res.status(500).json({ message: "ÏàòÏ†ï Ïã§Ìå®" });
    }
    
    // ÏóÖÎç∞Ïù¥Ìä∏Îêú ÏãúÍ∞ÑÌëú Ï†ïÎ≥¥ Ï°∞Ìöå
    const [updatedTimetable] = await pool.query(
      `SELECT t.*, s.name AS subject_name 
       FROM timetables t
       LEFT JOIN subjects s ON t.subject_id = s.id
       WHERE t.id = ?`,
      [id]
    );
    
    // ÍµêÏãú -> ÏãúÍ∞Ñ Îß§Ìïë Ï∂îÍ∞Ä
    const periodMap = await getPeriodMap();
    const formatted = {
      ...updatedTimetable[0],
      subject_name: updatedTimetable[0].subject_name || "ÎØ∏ÏßÄÏ†ï Í≥ºÎ™©",
      start_time: periodMap[updatedTimetable[0].start_period]?.start_time || "09:00",
      end_time: periodMap[updatedTimetable[0].end_period]?.end_time || "18:00"
    };
    
    // Í≤∞Í≥º Î∞òÌôò
    res.json({
      message: "ÏãúÍ∞ÑÌëú ÏàòÏ†ï ÏÑ±Í≥µ",
      timetable: formatted
    });
    
  } catch (err) {
    console.error("‚ùå updateTimetable Ïò§Î•ò:", err);
    res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù", error: err.message });
  }
};

/**
 * ÏãúÍ∞ÑÌëú ÏÇ≠Ï†ú API
 * DELETE /api/timetable/:id
 * 
 * Ï†ïÍ∑ú ÏàòÏóÖ ÎòêÎäî ÌäπÍ∞ï ÏÇ≠Ï†úÎ•º ÏúÑÌïú API
 */
exports.deleteTimetable = async (req, res) => {
  const { id } = req.params;

  if (!id) return res.status(400).json({ message: "IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§." });

  try {
    const [result] = await pool.query("DELETE FROM timetables WHERE id = ?", [id]);
    if (result.affectedRows === 0) {
      return res.status(404).json({ message: "ÏÇ≠Ï†úÌï† ÏàòÏóÖÏù¥ ÏóÜÏäµÎãàÎã§." });
    }

    res.json({ status: "success", message: "ÏÇ≠Ï†ú ÏôÑÎ£å", data: { id } });
  } catch (err) {
    console.error("‚ùå deleteTimetable Ïò§Î•ò:", err);
    res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù" });
  }
};

/**
 * Ïù¥Î≤§Ìä∏ Îì±Î°ù API
 * POST /api/timetable/events
 * 
 * Î≥¥Í∞ï/Ìú¥Í∞ï/ÌñâÏÇ¨ Ïù¥Î≤§Ìä∏ Îì±Î°ù
 */
exports.createEvent = async (req, res) => {
  const {
    timetable_id,
    subject_id,
    event_type,
    event_date,
    level,
    group_levels,
    start_period,
    end_period,
    description,
    year,
    inherit_attributes
  } = req.body;
  
  // ÌïÑÏàò ÌïÑÎìú Í≤ÄÏ¶ù
  if (!event_type || !event_date || !start_period || !end_period) {
    return res.status(400).json({ 
      message: "event_type, event_date, start_period, end_periodÎäî ÌïÑÏàò ÌïÑÎìúÏûÖÎãàÎã§." 
    });
  }
  
  // Ïù¥Î≤§Ìä∏ ÌÉÄÏûÖ Í≤ÄÏ¶ù
  const validEventTypes = ['makeup', 'cancel', 'event'];
  if (!validEventTypes.includes(event_type)) {
    return res.status(400).json({ 
      message: "Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ event_typeÏûÖÎãàÎã§. makeup, cancel, event Ï§ë ÌïòÎÇòÏó¨Ïïº Ìï©ÎãàÎã§." 
    });
  }
  
  // ÍµêÏãú Í≤ÄÏ¶ù
  if (parseInt(start_period) > parseInt(end_period)) {
    return res.status(400).json({ 
      message: "start_periodÎäî end_periodÎ≥¥Îã§ ÏûëÍ±∞ÎÇò Í∞ôÏïÑÏïº Ìï©ÎãàÎã§." 
    });
  }
  
  try {
    // Ïù¥Î≤§Ìä∏ Ï§ëÎ≥µ Ï≤¥ÌÅ¨
    if (timetable_id) {
      const [existing] = await pool.query(
        `SELECT * FROM timetable_events 
         WHERE timetable_id = ? AND event_date = ? AND event_type = ?`,
        [timetable_id, event_date, event_type]
      );
      
      if (existing.length > 0) {
        return res.status(409).json({ 
          message: "Ìï¥Îãπ ÎÇ†ÏßúÏóê ÎèôÏùºÌïú ÌÉÄÏûÖÏùò Ïù¥Î≤§Ìä∏Í∞Ä Ïù¥ÎØ∏ Îì±Î°ùÎêòÏñ¥ ÏûàÏäµÎãàÎã§." 
        });
      }
    }
    
    // group_levelsÍ∞Ä Î¨∏ÏûêÏó¥Î°ú Îì§Ïñ¥Ïò® Í≤ΩÏö∞ Ï≤òÎ¶¨
    let parsedGroupLevels = group_levels;
    if (typeof group_levels === 'string') {
      try {
        parsedGroupLevels = JSON.parse(group_levels);
      } catch (e) {
        parsedGroupLevels = [group_levels]; // Î¨∏ÏûêÏó¥ ÌïòÎÇòÎ•º Î∞∞Ïó¥Î°ú Î≥ÄÌôò
      }
    }
    
    // DBÏóê Ïù¥Î≤§Ìä∏ Ï†ÄÏû• - Ïª¨ÎüºÎ™Ö Ïã§Ï†ú ÌÖåÏù¥Î∏î Íµ¨Ï°∞Ïóê ÎßûÍ≤å ÏàòÏ†ï
    const [result] = await pool.query(
      `INSERT INTO timetable_events (
        timetable_id, subject_id, event_type, event_date, level, 
        group_levels, start_period, end_period, description, 
        year, inherit_attributes, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
      [
        timetable_id || null,
        subject_id || null,
        event_type,
        event_date,
        level || null,
        parsedGroupLevels ? JSON.stringify(parsedGroupLevels) : null,
        start_period,
        end_period,
        description || null,
        year || null,
        inherit_attributes === true || inherit_attributes === 1 ? 1 : 0 // Í∏∞Î≥∏Í∞íÏùÄ 1(true)
      ]
    );
    
    // ÏÉàÎ°ú ÏÉùÏÑ±Îêú Ïù¥Î≤§Ìä∏ Ï†ïÎ≥¥ Ï°∞Ìöå - ÏàòÏ†ïÎêú ÏøºÎ¶¨Î°ú Î≥ÄÍ≤Ω
    const [newEvent] = await pool.query(
      `SELECT e.*, s.name AS subject_name,
             t.professor_name AS inherited_professor_name,
             t.room AS inherited_room
       FROM timetable_events e
       LEFT JOIN subjects s ON e.subject_id = s.id
       LEFT JOIN timetables t ON e.timetable_id = t.id
       WHERE e.id = ?`,
      [result.insertId]
    );
    
    // ÍµêÏàòÎ™ÖÍ≥º Í∞ïÏùòÏã§ Ï≤òÎ¶¨ - inherit_attributesÍ∞Ä 1Ïù¥Î©¥ timetableÏóêÏÑú ÏÉÅÏÜç
    const formattedEvent = {
      ...newEvent[0],
      professor_name: newEvent[0].inherited_professor_name || "ÎØ∏ÏßÄÏ†ï ÍµêÏàò",
      room: newEvent[0].inherited_room || "",
      inherited_professor_name: newEvent[0].inherited_professor_name || null,
      inherited_room: newEvent[0].inherited_room || null
    };
    
    // Í≤∞Í≥º Î∞òÌôò
    res.status(201).json({
      message: "Ïù¥Î≤§Ìä∏ Îì±Î°ù ÏÑ±Í≥µ",
      event: formattedEvent
    });
    
  } catch (err) {
    console.error("‚ùå createEvent Ïò§Î•ò:", err);
    res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù", error: err.message });
  }
};

/**
 * Ïù¥Î≤§Ìä∏ ÏàòÏ†ï API
 * PUT /api/timetable/events/:id
 * 
 * Î≥¥Í∞ï/Ìú¥Í∞ï/ÌñâÏÇ¨ Ïù¥Î≤§Ìä∏ ÏàòÏ†ï
 */
exports.updateEvent = async (req, res) => {
  const { id } = req.params;
  const {
    timetable_id,
    subject_id,
    event_type,
    event_date,
    level,
    group_levels,
    start_period,
    end_period,
    description,
    year,
    inherit_attributes
  } = req.body;
  
  if (!id) return res.status(400).json({ message: "IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§." });
  
  try {
    // Ïù¥Î≤§Ìä∏ Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏
    const [existingRows] = await pool.query("SELECT * FROM timetable_events WHERE id = ?", [id]);
    if (existingRows.length === 0) {
      return res.status(404).json({ message: "ÏàòÏ†ïÌï† Ïù¥Î≤§Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§." });
    }
    
    // ÏàòÏ†ïÌï† ÌïÑÎìú Íµ¨ÏÑ±
    const updates = [];
    const params = [];
    
    if (timetable_id !== undefined) {
      updates.push("timetable_id = ?");
      params.push(timetable_id);
    }
    
    if (subject_id !== undefined) {
      updates.push("subject_id = ?");
      params.push(subject_id);
    }
    
    if (event_type !== undefined) {
      // Ïù¥Î≤§Ìä∏ ÌÉÄÏûÖ Í≤ÄÏ¶ù
      const validEventTypes = ['makeup', 'cancel', 'event'];
      if (!validEventTypes.includes(event_type)) {
        return res.status(400).json({ 
          message: "Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ event_typeÏûÖÎãàÎã§. makeup, cancel, event Ï§ë ÌïòÎÇòÏó¨Ïïº Ìï©ÎãàÎã§." 
        });
      }
      updates.push("event_type = ?");
      params.push(event_type);
    }
    
    if (event_date !== undefined) {
      updates.push("event_date = ?");
      params.push(event_date);
    }
    
    if (level !== undefined) {
      updates.push("level = ?");
      params.push(level);
    }
    
    if (start_period !== undefined) {
      updates.push("start_period = ?");
      params.push(start_period);
    }
    
    if (end_period !== undefined) {
      updates.push("end_period = ?");
      params.push(end_period);
    }
    
    if (description !== undefined) {
      updates.push("description = ?");
      params.push(description);
    }
    
    if (year !== undefined) {
      updates.push("year = ?");
      params.push(year);
    }
    
    if (group_levels !== undefined) {
      // group_levelsÍ∞Ä Î¨∏ÏûêÏó¥Î°ú Îì§Ïñ¥Ïò® Í≤ΩÏö∞ Ï≤òÎ¶¨
      let parsedGroupLevels = group_levels;
      if (typeof group_levels === 'string') {
        try {
          parsedGroupLevels = JSON.parse(group_levels);
        } catch (e) {
          parsedGroupLevels = [group_levels]; // Î¨∏ÏûêÏó¥ ÌïòÎÇòÎ•º Î∞∞Ïó¥Î°ú Î≥ÄÌôò
        }
      }
      
      updates.push("group_levels = ?");
      params.push(parsedGroupLevels ? JSON.stringify(parsedGroupLevels) : null);
    }
    
    if (inherit_attributes !== undefined) {
      updates.push("inherit_attributes = ?");
      params.push(inherit_attributes === true || inherit_attributes === 1 ? 1 : 0);
    }
    
    // ÏàòÏ†ïÌï† ÎÇ¥Ïö©Ïù¥ ÏóÜÎäî Í≤ΩÏö∞
    if (updates.length === 0) {
      return res.status(400).json({ message: "ÏàòÏ†ïÌï† ÎÇ¥Ïö©Ïù¥ ÏóÜÏäµÎãàÎã§." });
    }
    
    // ÏóÖÎç∞Ïù¥Ìä∏ ÏøºÎ¶¨ Ïã§Ìñâ
    const updateQuery = `UPDATE timetable_events SET ${updates.join(', ')}, updated_at = NOW() WHERE id = ?`;
    params.push(id);
    
    const [result] = await pool.query(updateQuery, params);
    
    if (result.affectedRows === 0) {
      return res.status(500).json({ message: "ÏàòÏ†ï Ïã§Ìå®" });
    }
    
    // ÏóÖÎç∞Ïù¥Ìä∏Îêú Ïù¥Î≤§Ìä∏ Ï†ïÎ≥¥ Ï°∞Ìöå
    const [newEvent] = await pool.query(
      `SELECT e.*, s.name AS subject_name,
             t.professor_name AS inherited_professor_name,
             t.room AS inherited_room
       FROM timetable_events e
       LEFT JOIN subjects s ON e.subject_id = s.id
       LEFT JOIN timetables t ON e.timetable_id = t.id
       WHERE e.id = ?`,
      [id]
    );
    
    // ÍµêÏàòÎ™ÖÍ≥º Í∞ïÏùòÏã§ Ï≤òÎ¶¨ - inherit_attributesÍ∞Ä 1Ïù¥Î©¥ timetableÏóêÏÑú ÏÉÅÏÜç
    const formattedEvent = {
      ...newEvent[0],
      professor_name: newEvent[0].inherited_professor_name || "ÎØ∏ÏßÄÏ†ï ÍµêÏàò",
      room: newEvent[0].inherited_room || "",
      inherited_professor_name: newEvent[0].inherited_professor_name || null,
      inherited_room: newEvent[0].inherited_room || null
    };
    
    // Í≤∞Í≥º Î∞òÌôò
    res.json({
      message: "Ïù¥Î≤§Ìä∏ ÏàòÏ†ï ÏÑ±Í≥µ",
      event: formattedEvent
    });
    
  } catch (err) {
    console.error("‚ùå updateEvent Ïò§Î•ò:", err);
    res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù", error: err.message });
  }
};

/**
 * Ïù¥Î≤§Ìä∏ ÏÇ≠Ï†ú API
 * DELETE /api/timetable/events/:id
 * 
 * Î≥¥Í∞ï/Ìú¥Í∞ï/ÌñâÏÇ¨ Ïù¥Î≤§Ìä∏ ÏÇ≠Ï†ú
 */
exports.deleteEvent = async (req, res) => {
  const { id } = req.params;

  if (!id) return res.status(400).json({ message: "IDÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§." });

  try {
    const [result] = await pool.query("DELETE FROM timetable_events WHERE id = ?", [id]);
    if (result.affectedRows === 0) {
      return res.status(404).json({ message: "ÏÇ≠Ï†úÌï† Ïù¥Î≤§Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§." });
    }

    res.json({ status: "success", message: "Ïù¥Î≤§Ìä∏ ÏÇ≠Ï†ú ÏôÑÎ£å", data: { id } });
  } catch (err) {
    console.error("‚ùå deleteEvent Ïò§Î•ò:", err);
    res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò Î∞úÏÉù" });
  }
};